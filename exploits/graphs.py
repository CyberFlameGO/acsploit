from input import Generator
from acsploit import Exploit, Option

class GraphExploit(Exploit):
    @staticmethod
    def start_instance():
        prompt = GraphExploit()
        prompt.prompt = "exploit(graph)$ "
        prompt.cmdloop("Exploit Graph Algorithms. Type \'options\' for current settings")

    def get_options(self):
        return dict({
            'directed' : Option('directed', 'bool', True),
            'weighted' : Option('weighted', 'bool', True),
            'n_inputs' : Option('n_inputs', 'int', 10)})

    def run(self, generator, options):
        if options['directed'].value and options['weighted'].value:
            print(self.kruskal(generator, options['n_inputs'].value, options['directed'].value))
        elif (not options['directed'].value) and options['weighted'].value:
            print(self.fleury(generator, options['n_inputs'].value, options['directed'].value))

    def fleury(self, generator, n_inputs, directed):
        G = {}
        possible_nodes = []
        n = generator.get_min_value()[0]
        for i in range(n_inputs):
            possible_nodes.append(n)
            G[n] = set()
            n = generator.get_greater_than(n)
        for i in range(n_inputs):
            for n in range(n_inputs):
                if not directed:
                    if G[possible_nodes[i]] not in G[possible_nodes[n]]:
                        G[possible_nodes[i]].add(possible_nodes[n])
                else:
                    G[possible_nodes[i]].add(possible_nodes[n])
        formatted_output = ""
        for node in G:
            formatted_output += (node + ": ")
            first = True
            for connection in G[node]:
                if first:
                    formatted_output += connection
                    first = False
                else:
                    formatted_output += (", " + connection)
            formatted_output += "\n"

        return formatted_output

    def kruskal(self, generator, n_inputs, directed):
        G = {}
        weight = 1  # Should be minimum positive value, but 1 seems unlikely to be outside range
        possible_nodes = []
        n = generator.get_random()[0]
        if type(generator.get_min_value) == int:
            n = 0  # Avoid obnoxious int names
        for i in range(n_inputs):
            possible_nodes.append(n)
            n = generator.get_greater_than(n)
        for i in range(n_inputs):
            G[possible_nodes[i]] = []
            for n in range(n_inputs):
                if not directed:
                    if (possible_nodes[n], weight) not in G[possible_nodes[i]]:
                        G[possible_nodes[i]].append((possible_nodes[n], weight))
                else:
                    G[possible_nodes[i]].append((possible_nodes[n], weight))
        formatted_output = ""
        for node in G:
            formatted_output += (str(node) + ": ")
            first = True
            for connection in G[node]:
                if first:
                    formatted_output += str(connection)
                    first = False
                else:
                    formatted_output += (", " + str(connection))
            formatted_output += "\n"
        return formatted_output
