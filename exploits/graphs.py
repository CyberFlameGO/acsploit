from input import Generator

# TODO: Fix weighted, undirected graph

class GraphExploit():

    options = dict({'directed' : False, 'weighted': False , 'n_inputs':10})
    descriptions = dict({'directed' : "True or False.", 'weighted': "True or False" , 'n_inputs': 'Number of nodes in graph.'})

    def run(self, generator):
        directed = False
        if isinstance(self.options['directed'], bool) and self.options['directed'] == True:
            directed = True
        if isinstance(self.options['directed'], str) and (self.options['directed'].lower == "true"):
            directed = True

        if isinstance(self.options['weighted'], bool) and (self.options['weighted'] == True):
            print(self.kruskal(generator, int(self.options['n_inputs']), directed))
        elif (isinstance('ssr', str)):
            pass
        elif (isinstance(self.options['weighted'], str)) and (self.options['weighted'].lower == "true"):
            print(self.kruskal(generator, int(self.options['n_inputs']), directed))
        else:
            print(self.fleury(generator, int(self.options['n_inputs']), directed))

    def fleury(self, generator, n_inputs, directed):
        G = {}
        possible_nodes = []
        n = generator.get_min_value()
        for i in range(n_inputs):
            possible_nodes.append(n)
            G[n] = set()
            n = generator.get_greater_than(n)
        for i in range(n_inputs):
            for n in range(n_inputs):
                if not directed:

                    if possible_nodes[i] not in G[possible_nodes[n]]:

                        G[possible_nodes[i]].add(possible_nodes[n])

                else:
                    G[possible_nodes[i]].add(possible_nodes[n])
        formatted_output = ""
        for node in G:
            formatted_output += (str(node) + ": ")
            first = True
            for connection in G[node]:
                if first:
                    formatted_output += str(connection)
                    first = False
                else:
                    formatted_output += (", " + str(connection))
            formatted_output += "\n"
        G = formatted_output
        return G

    def kruskal(self, generator, n_inputs, directed):
        G = {}
        weight = 1  # Should be minimum positive value, but 1 seems unlikely to be outside range
        possible_nodes = []
        n = generator.get_min_value()
        if type(generator.get_min_value) == int:
            n = 0  # Avoid obnoxious int names
        for i in range(n_inputs):
            possible_nodes.append(n)
            n = generator.get_greater_than(n)
        for i in range(n_inputs):
            G[possible_nodes[i]] = []
            for n in range(n_inputs):
                if not directed:
                    #print((possible_nodes[n], weight))
                    #print(G[possible_nodes[i]])
                    if (possible_nodes[i], weight) not in G[possible_nodes[n]]:
                        G[possible_nodes[i]].append((possible_nodes[n], weight))
                else:
                    G[possible_nodes[i]].append((possible_nodes[n], weight))
        formatted_output = ""
        for node in G:
            formatted_output += (str(node) + ": ")
            first = True
            for connection in G[node]:
                if first:
                    formatted_output += str(connection)
                    first = False
                else:
                    formatted_output += (", " + str(connection))
            formatted_output += "\n"
        G = formatted_output

        return G
