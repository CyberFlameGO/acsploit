from input import Generator
import hashlib
import sys
from itertools import permutations
from itertools import product
from z3 import *

class HashmapExploit():
    f = None
    n = -1
    options=dict({
            "type": "java",
            "n_collisions": 10,
            "target": 0,
            "bits": 32,
            "length": 10,
            "hash_table_size": 100
            })

    descriptions=dict({
            "type": "One of java, z3hash or md5.",
            "n_collisions": "Number of collisions to create.",
            "target": "Desired hash value (only for java).",
            "bits": "Something for md5 (???).",
            "length": "Length of desired unhashed strings.",
            "hash_table_size": "Size of target hash table."
            })

    def run(self, generator):
        if self.options['type']=='md5':
            self.f = eval("hashlib." + self.options['type'])  # this should check to make sure the function exists
            self.n = int(self.options['bits']/4)
            print(self.exploit(generator, int(self.options['n_collisions'])))
        elif self.options['type']=='java':
            self.GenerateJavaPreimages(generator,self.options['target'], int(self.options['n_collisions']))
        elif self.options['type']=='z3hash':
            self.getcollisions(str(self.options['target']),self.options['length'],self.options['n_collisions'], self.options['hash_table_size'])
    
    def exploit(self, generator, n_inputs):
        keys = []
        hash_pairs = dict()  # hash -> key
        hashes = set()
        generated = set()
        hash_f = self.hash_function

        # Currently can only generate multiple pairs of keys that generate the same hash
        while len(keys) < n_inputs:
            current_value = generator.get_random()
            hash = hash_f(current_value)

            while hash not in hashes:
                hash_pairs[hash] = current_value
                generated.add(current_value)
                hashes.add(hash)
                find_val = generator.get_random()
                while find_val in generated:
                    find_val = generator.get_random()
                current_value = find_val
                hash = hash_f(current_value)
            keys.append(current_value)
            keys.append(hash_pairs[hash_f(current_value)])

        return keys

    def hash_function(self, key):
        h = self.f

        return h(repr(key).encode('utf-8')).hexdigest()[:self.n] # this is wrong

    def JavaHash(self,inputstring):
        result=0
        n=len(inputstring)
        for i in range(0, n):
            result+= 31** (n-i) * ord(inputstring[i]);
        return result % (2**32);
    
    def GenerateJavaHashStrings(self,generator,halflength):
        keys={}
        if type(generator).__name__=="CharGenerator":
            characters=generator.characters
        elif type(generator).__name__=="IntGenerator":       
            characters=range(generator.get_min_value(),generator.get_max_value())
        elif type(generator).__name__=="StringGenerator":
            characters=generator.char_gen.characters
        else:
             characters=[]
        for i in product(characters, repeat=halflength):  #This only does uppercase letters, fix in future to allow for other input
            keys[self.JavaHash(i)]=''.join(i)
        return keys
    
    def GenerateJavaPreimages(self,generator, target, collisions): 
        length=1 #We don't often find small collisions, we can start at length 6.
        current=0
        while (current < collisions):
            if (length % 2 == 0):
                multfactor = 31 ** (length / 2)
                keys=self.GenerateJavaHashStrings(generator,int(length/2))
                for subhash,substring in keys.iteritems():
                    effectiveTarget = (target-(subhash * multfactor))% (2 ** 32)
                    if effectiveTarget in keys:
                        poststring=keys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if (current >=collisions):
                            break
                length+=1
            else:
                multfactor2 = 31 ** ((length-1)/2)
                keys = self.GenerateJavaHashStrings(generator,int((length+1)/2))
                otherkeys=self.GenerateJavaHashStrings(generator, int((length-1)/2))
                for subhash, substring in keys.iteritems():
                    effectiveTarget = (target - (subhash * multfactor2)) % (2 ** 32)
                    if effectiveTarget in otherkeys:
                        poststring = otherkeys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if (current >= collisions):
                            break
                length+=1
    def z3hash(self,bytes, hash_table_size): #Example hash function
        h = 0
        for byte in bytes:
            h = h * 31 + z3.ZeroExt(24,byte) # Does the hash byte by byte (can easily change the logic here)
        return h % hash_table_size #mods out by hash table size
    
    def ascii_printable(self,x):
        '''Adds the constraints to have an ascii printable byte'''
        return z3.And(0x20 <= x, x <= 0x7f)
    
    def generate_ascii_printable_string(self,base_name, size, solver):
        '''Generates a sequence of byte you can use as something to simulate C strings,
        and also adds to the solver the required constraints to have an ascii printable string'''
        bytes = [z3.BitVec('%s%d' % (base_name, i), 8) for i in range(size)]
        solver.add(z3.And(map(self.ascii_printable, bytes)))
        return bytes
    
    def str_to_BitVecVals8(self,s):
        '''Generates a list of BitVecVal8 from a python string'''
        return map(
            lambda x: z3.BitVecVal(ord(x), 8),
            list(s)
        )
    
    def getcollisions(self,target, length,n_collisions, hash_table_size):
        s = z3.Solver()
        res = self.generate_ascii_printable_string('res',length,s)
        s.add(self.z3hash(res, hash_table_size) == self.z3hash(self.str_to_BitVecVals8(target), hash_table_size))
        count=0
        while s.check() == sat and count<n_collisions:
            x = s.model()
            y= ''.join(chr(x[i].as_long()) for i in res[-length:])
            print y
            count=count+1
            s.add(z3.Or(res[0] !=x[res[-length+0]], res[1]!=x[res[-length+1]], res[2] !=x[res[-length+2]]))  #Change this to eval at some point, should iterate over all positions, not just the first three
            if count >= n_collisions:
                return
        raise Exception('Unsat!')

