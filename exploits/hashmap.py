from input import Generator
import hashlib
import sys
from itertools import permutations
from itertools import product
from z3 import *

class HashmapExploit():
    f = None
    n = -1
    options=dict({
            "type": "java",
            "n_collisions": 10,
            "target": 0,
            "bits": 32,
            "length": 10,
            "hash_table_size": 100,
            "z3hashtype": "dummy"
            })

    descriptions=dict({
            "type": "One of java, z3hash or md5.",
            "n_collisions": "Number of collisions to create.",
            "target": "Desired hash value (only for java).",
            "bits": "Something for md5 (???).",
            "length": "Length of desired unhashed strings.",
            "hash_table_size": "Size of target hash table.",
            "z3hashtype": "Only applicable to type: z3hash. Can be set to dummy, fletcher, adler32, java, sum, xor8 or bsd."
            })

    def run(self, generator):
        if self.options['type']=='md5':
            self.f = eval("hashlib." + self.options['type'])  # this should check to make sure the function exists
            self.n = int(self.options['bits']/4)
            print(self.exploit(generator, int(self.options['n_collisions'])))
        elif self.options['type']=='java':
            self.GenerateJavaPreimages(generator,self.options['target'], int(self.options['n_collisions']))
        elif self.options['type']=='z3hash':
            self.getcollisions(str(self.options['target']),int(self.options['length']),int(self.options['n_collisions']), int(self.options['hash_table_size']))
    
    def exploit(self, generator, n_inputs):
        keys = []
        hash_pairs = dict()  # hash -> key
        hashes = set()
        generated = set()
        hash_f = self.hash_function

        # Currently can only generate multiple pairs of keys that generate the same hash
        while len(keys) < n_inputs:
            current_value = generator.get_random()
            hash = hash_f(current_value)

            while hash not in hashes:
                hash_pairs[hash] = current_value
                generated.add(current_value)
                hashes.add(hash)
                find_val = generator.get_random()
                while find_val in generated:
                    find_val = generator.get_random()
                current_value = find_val
                hash = hash_f(current_value)
            keys.append(current_value)
            keys.append(hash_pairs[hash_f(current_value)])

        return keys

    def hash_function(self, key):
        h = self.f

        return h(repr(key).encode('utf-8')).hexdigest()[:self.n] # this is wrong

    def JavaHash(self,inputstring):
        result=0
        n=len(inputstring)
        for i in range(0, n):
            result+= 31** (n-i) * ord(inputstring[i]);
        return result % (2**32);
    
    def GenerateJavaHashStrings(self,generator,halflength):
        keys={}
        if type(generator).__name__=="CharGenerator":
            characters=generator.characters
        elif type(generator).__name__=="IntGenerator":       
            characters=range(generator.get_min_value(),generator.get_max_value())
        elif type(generator).__name__=="StringGenerator":
            characters=generator.char_gen.characters
        else:
             characters=[]
        for i in product(characters, repeat=halflength):  #This only does uppercase letters, fix in future to allow for other input
            keys[self.JavaHash(i)]=''.join(i)
        return keys
    
    def GenerateJavaPreimages(self,generator, target, collisions): 
        length=1 #We don't often find small collisions, we can start at length 6.
        current=0
        while (current < collisions):
            if (length % 2 == 0):
                multfactor = 31 ** (length / 2)
                keys=self.GenerateJavaHashStrings(generator,int(length/2))
                for subhash,substring in keys.iteritems():
                    effectiveTarget = (target-(subhash * multfactor))% (2 ** 32)
                    if effectiveTarget in keys:
                        poststring=keys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if (current >=collisions):
                            break
                length+=1
            else:
                multfactor2 = 31 ** ((length-1)/2)
                keys = self.GenerateJavaHashStrings(generator,int((length+1)/2))
                otherkeys=self.GenerateJavaHashStrings(generator, int((length-1)/2))
                for subhash, substring in keys.iteritems():
                    effectiveTarget = (target - (subhash * multfactor2)) % (2 ** 32)
                    if effectiveTarget in otherkeys:
                        poststring = otherkeys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if (current >= collisions):
                            break
                length+=1
    def z3hash(self,bytes, hash_table_size): #Example hash function. This can be any simple arithmetic hash, feel free to change to suit your needs
        if self.options['z3hashtype']=='dummy':
            h = 0
            for byte in bytes:
                h = h * 31 + z3.ZeroExt(24,byte) # Does the hash byte by byte (can easily change the logic here)
            return h % hash_table_size #mods out by hash table size
        elif self.options['z3hashtype']=='fletcher':
            return self.z3fletcher(bytes,hash_table_size)
        elif self.options['z3hashtype']=='adler32':
            return self.z3adler32(bytes,hash_table_size)
        elif self.options['z3hashtype']=='sum':
            return self.z3sum(bytes,hash_table_size)
        elif self.options['z3hashtype']=='java':
            return self.z3java(bytes,hash_table_size)
        elif self.options['z3hashtype']=='bsd':
            return self.z3bsd(bytes,hash_table_size)
        elif self.options['z3hashtype']=='xor8':
            return self.z3xor8(bytes,hash_table_size)
        else:
            return      

    def z3fletcher(self,bytes,hash_table_size): # computes the z3form of the fletcher checksum
        v1=0
        v2=0
        for byte in bytes:
            v1=v1+z3.ZeroExt(24,byte) %hash_table_size
            v2=v2+v1 %hash_table_size
        return v2+v1 %hash_table_size
    
    def z3adler32(self,bytes,hash_table_size): #computes the z3 form of the adler32 checksum (modulo hash table size)
        v1=0
        v2=0
        for byte in bytes:
            v1=v1+z3.ZeroExt(24,byte) %65521
            v2=v2+v1 %65521 
        return (v2*65536+v1) %hash_table_size 
    
    def z3sum(self,bytes,hash_table_size): #computes the z3 form of the sum of all bytes in the string
        v1=0
        for byte in bytes:
            v1=v1+z3.ZeroExt(24,byte) 
        return v1 %hash_table_size

    def z3java(self,bytes,hash_table_size): #computes the default java hash in z3 form.
        v1=0
        n=len(bytes)
        i=0
        for byte in bytes:
            v1+= 31**(n-i)* z3.ZeroExt(24,byte)
            i+=1
        return v1 %hash_table_size 

    def z3crc32(self,bytes,hash_table_size):
        table=self.build_crc_tables()
        crc = 0xffffffff
        for byte in bytes:
            crc = (crc >> 8) ^ table[(crc ^ z3.ZeroExt(24,byte)) & 0xff] 
        return crc^0xffffffff
    
    def build_crc_tables(self): #add polynomials???
        polynom=0xedb88320  
        table=[0]*256
        for i in range(256):
           fwd = i
           rev = i << 24
           for j in range(8, 0, -1):
              # build normal table
              if (fwd & 1) == 1:
                 fwd = (fwd >> 1) ^ polynom
              else:
                 fwd >>= 1
              table[i] = fwd & 0xffffffff
        return table

    def z3bsd(self,bytes,hash_table_size): #computes the bsd checksum in z3 format. 
        checksum=0
        for byte in bytes:
            checksum=(checksum >>1) +((checksum &1) <<15)
            checksum += ZeroExt(24,byte)
            checksum &=0xffff
        return checksum

    def z3xor8(self,bytes,hash_table_size):
        lrc=0
        for byte in bytes:
            lrc=(lrc+ZeroExt(24,byte)) &0xff
        lrc=(((lrc ^0xff) +1 ) & 0xff)
        return lrc


    def ascii_printable(self,x):
        return z3.And(0x20 <= x, x <= 0x7f) #enforces that byte is printable ascii
    
    def generate_ascii_printable_string(self,base_name, size, solver):
        bytes = [z3.BitVec('%s%d' % (base_name, i), 8) for i in range(size)] #Establishes z3 variable names for bytes of the input string
        solver.add(z3.And(map(self.ascii_printable, bytes)))  # adds the constraint that the bytes are printable ascii
        return bytes
    
    def str_to_BitVecVals8(self,string): #sets the target sring into Z3 BitVecVals
        return map(
            lambda x: z3.BitVecVal(ord(x), 8), 
            list(string)
        )
    
    def getcollisions(self,target, length,n_collisions, hash_table_size):
        s = z3.Solver()
        res = self.generate_ascii_printable_string('res',length,s)# Houses the z3 variables for the potential hash match
        s.add(self.z3hash(res, hash_table_size) == self.z3hash(self.str_to_BitVecVals8(target), hash_table_size)) #enforces the z3 constraint that the hash matches the hash of the target string 
        count=0
        while s.check() == sat and count<n_collisions: #Z3 isn't stateful, you basically have to run it again and again while adding contraints to ignore previous solutions
            x = s.model() #This is a Z3 solution
            y= ''.join(chr(x[i].as_long()) for i in res[-length:])
            print y #print the solution
            count=count+1
            s.add(z3.Or(res[0] !=x[res[-length+0]], res[1]!=x[res[-length+1]], res[2] !=x[res[-length+2]]))  #Change this to eval at some point, should iterate over all positions, not just the first three
            if count >= n_collisions:
                return #Exit after you have enough collisions
        raise Exception('Unsat!') #raises this exception when you can't find any more solutions. Maybe change this to be more elegant in the future?

