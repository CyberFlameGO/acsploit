from input import Generator
from acsploit import Exploit, Option
import hashlib

class HashmapExploit(Exploit):
    f = None
    n = -1
    @staticmethod
    def start_instance():
        prompt = HashmapExploit()
        prompt.prompt = "exploit(hashmap)$ "
        prompt.cmdloop("Exploit Hashmap. Type \'options\' for current settings") #This is shown when the CLI is first opened

    def get_options(self):
        # TODO: Eventually be able to input a completely custom hash function
        return dict({
            'function' : Option('type', 'string', 'md5'),
            'n_inputs' : Option('n_inputs', 'int', 10),
            'bits'     : Option('bits', 'int', 32)
            })

    def run(self, generator, options):
        self.f = eval("hashlib." + options['function'].value)  # this should check to make sure the function exists
        self.n = int(options['bits'].value/4)
        print(self.exploit(generator, options['n_inputs'].value))

    def exploit(self, generator, n_inputs):
        keys = []
        hash_pairs = dict()  # hash -> key
        hashes = set()
        generated = set()
        hash_f = self.hash_function

        # Currently can only generate multiple pairs of keys that generate the same hash
        while len(keys) < n_inputs:
            current_value = generator.get_random()
            hash = hash_f(current_value)

            while hash not in hashes:
                hash_pairs[hash] = current_value
                generated.add(current_value)
                hashes.add(hash)
                find_val = generator.get_random()
                while find_val in generated:
                    find_val = generator.get_random()
                current_value = find_val
                hash = hash_f(current_value)
            keys.append(current_value)
            keys.append(hash_pairs[hash_f(current_value)])

        return keys

    def hash_function(self, key):
        h = self.f

        return h(repr(key).encode('utf-8')).hexdigest()[:self.n]
