class binary_search_tree():

    options = {
        'function': 'search',
        'n_nodes': 10}
    descriptions = {
        'function': 'The tree function. One of search, min, max, insert, delete',
        'n_nodes': 'Number of nodes in tree'}

    def run(self, generator):
        f = self.options['function']
        if f == 'search' or f == 'min' or f == 'delete':
            print 'Tree insertion order:'
            sorted = self.sorted_list(generator, int(self.options['n_nodes']))
            print sorted
            if f == 'search':
               print 'Search for : %s' % sorted[int(self.options['n_nodes'])-1]
            elif f == 'delete':
               print 'Delete : %s' % sorted[int(self.options['n_nodes'])-1]
        elif f == 'insert':
            print 'Tree insertion order:'
            sorted = self.sorted_list(generator, int(self.options['n_nodes'])+1)
            print sorted[:-1]
            print 'Insert : %s' % sorted[-1]
        elif f == 'max':
            print 'Tree insertion order:'
            sorted = list(reversed(self.sorted_list(generator, int(self.options['n_nodes']))))
            print sorted
        else:
            print 'Not a valid function for binary search trees.'

    def sorted_list(self, generator, n_inputs):
        output = [generator.get_max_value()]
        for i in range(1, n_inputs):
            output.append(generator.get_less_than(output[i - 1]))
        return output
