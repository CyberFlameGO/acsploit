import string
import z3

from options import Options

options = Options()
options.add_option('hash', '+ * x y z', 'The hash function to use, in prefix notation')
options.add_option('target_value', 0, 'The target value to solve the inputs to the hash function for')
options.add_option('n_collisions', 10, 'The number of colliding inputs to solve for')

DESCRIPTION = 'Produces hash collisions for a custom hash function'


def run(generator, output):
    ast = parse_input(options['hash'])
    z3_expression = ast.convert_to_z3()

    solver = z3.Solver()
    solver.add(options['target_value'] == z3_expression)

    solutions = []
    while solver.check() == z3.sat and len(solutions) < options['n_collisions']:
        solution = solver.model()
        solutions.append(solution)
        # prevent duplicate solutions
        solver.add(z3.Or([var() != solution[var] for var in solution]))

    output.output(solutions)


class Node(object):
    CONSTANT = 0
    VARIABLE = 1

    ADDITION = 10
    SUBTRACTION = 11
    MULTIPLICATION = 12
    DIVISION = 13

    # arithmetic shifts
    LEFT_SHIFT = 20
    RIGHT_SHIFT = 21

    # bitwise logic
    AND = 30
    OR = 31

    VARIABLE_WIDTH = 8  # each variable is one byte
    TARGET_WIDTH = 32  # bit width of target values

    VARIABLE_CHARS = string.ascii_lowercase
    OPERATION_CHARS = {
        '+': ADDITION,
        '-': SUBTRACTION,
        '*': MULTIPLICATION,
        '/': DIVISION,
        '<<': LEFT_SHIFT,
        '>>': RIGHT_SHIFT,
        '&': AND,
        '|': OR
    }

    # TODO: enforce uniqueness of variables!

    def __init__(self, operation, left, right=None):
        self.operation = operation
        self.left = left
        self.right = right

    def __str__(self):
        s = 'Node: %i ' % id(self)
        s += '(Op: %s, ' % str(self.operation)
        if self.operation in [Node.CONSTANT, Node.VARIABLE]:
            s += 'Value: %s)' % str(self.left)
            assert self.right is None  # TODO: this should be elsewhere
        else:  # actual operation
            s += 'Left: %i, ' % id(self.left)
            s += 'Right: %i)' % id(self.right)
        return s

    def print_tree(self):
        print(str(self))
        if type(self.left) is Node:
            self.left.print_tree()
        if type(self.right) is Node:
            self.right.print_tree()

    def convert_to_z3(self):
        if self.operation == Node.CONSTANT:
            return z3.BitVecVal(self.left, Node.TARGET_WIDTH)
        elif self.operation == Node.VARIABLE:
            var = z3.BitVec(self.left, Node.VARIABLE_WIDTH)
            return z3.ZeroExt(Node.TARGET_WIDTH - Node.VARIABLE_WIDTH, var)
        else:  # operation
            left = self.left.convert_to_z3()
            right = self.right.convert_to_z3()
            if self.operation == Node.ADDITION:
                return left + right
            elif self.operation == Node.SUBTRACTION:
                return left - right
            elif self.operation == Node.MULTIPLICATION:
                return left * right
            elif self.operation == Node.DIVISION:
                return left / right
            elif self.operation == Node.LEFT_SHIFT:
                return left << right
            elif self.operation == Node.RIGHT_SHIFT:
                return left >> right
            elif self.operation == Node.AND:
                return left & right
            elif self.operation == Node.OR:
                return left | right
        raise LookupError('Unknown operation: %s' % str(self.operation))

    @staticmethod
    def make_constant(value):
        return Node(Node.CONSTANT, value)

    @staticmethod
    def make_variable(variable_name):
        return Node(Node.VARIABLE, variable_name)

    @staticmethod
    def make_operation(operation, left, right):
        return Node(operation, left, right)


def parse_input(input):
    atoms = input.split(' ')
    tree, atoms = parse_atom(atoms)
    assert len(atoms) == 0
    return tree


def parse_atom(atoms):
    assert len(atoms) > 0

    constant = parse_constant(atoms[0])
    if constant is not None:
        return Node.make_constant(constant), atoms[1:]

    variable = parse_variable(atoms[0])
    if variable is not None:
        return Node.make_variable(variable), atoms[1:]

    operation = parse_operation(atoms[0])
    if operation is not None:
        left, atoms = parse_atom(atoms[1:])  # pop operation off of atoms
        right, atoms = parse_atom(atoms)
        return Node.make_operation(operation, left, right), atoms


def parse_constant(atom):
    # only support base 10 for now
    try:
        return int(atom)
    except ValueError:
        return None


def parse_variable(atom):
    for char in atom:
        if char not in Node.VARIABLE_CHARS:
            return None
    return atom


def parse_operation(atom):
    try:
        return Node.OPERATION_CHARS[atom]
    except KeyError:
        return None
