import itertools
from options import Options


options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('hash_table_size', 2**32, 'Size of target hash table')
options.add_option('target_type', 'preimage', 'Whether the target is an image (hash output) or preimage (hash input)',
                   ['image', 'preimage'])
options.add_option('target', 'hello', 'Image or preimage of desired hash value')

DESCRIPTION = 'Produces hash collisions for the PHP 5 hash function'

DEFAULT_INPUT = 'char'


def run(generator, output):
    forbidden_string = ''
    if options['target_type'] == 'preimage':
        target = php_hash(options['target'], options['hash_table_size'])
        forbidden_string = options['target']
    else:
        target = int(options['target'])

    ret = generate_php_preimages(generator, target, options['n_collisions'],
                                 options['hash_table_size'], forbidden_string)
    output.output(ret)


def php_hash(inputstring, hash_table_size):
    result = 5381
    for c in inputstring:
        result *= 33
        result += ord(c)
    result %= 2**32
    return result % hash_table_size


def generate_php_hash_strings(generator, half_length, hash_table_size):
    keys = {}
    characters = generator.get_char_set()
    for s in itertools.product(characters, repeat=half_length):
        hash_val = php_hash(s, hash_table_size)
        keys[hash_val] = ''.join(s)
    return keys


def generate_php_preimages(generator, target, collisions, hash_table_size, forbidden_string):
    length = 1  # We could start higher but the first lengths go quickly so why not?
    pre_keys = {0: ''}
    post_keys = generate_php_hash_strings(generator, 1, hash_table_size)
    multfactor = 33  # should always equal 33 ** length of post_strings in post_keys
    ret = []

    while True:
        for pre_hash in pre_keys:

            effective_target = (target - (pre_hash * multfactor) + 5381 * multfactor) % hash_table_size
            if effective_target in post_keys:
                pre_string = pre_keys[pre_hash]
                post_string = post_keys[effective_target]
                if pre_string + post_string != forbidden_string:
                    ret.append(pre_string + post_string)

                if len(ret) >= collisions:
                    ret.sort()
                    return ret

        # Update variables for next loop
        length += 1
        pre_keys = post_keys  # pre_keys follows 1 step behind post_keys
        if length % 2 != 0:
            # we update to a longer post_keys at every odd length
            post_keys = generate_php_hash_strings(generator, 1 + length // 2, hash_table_size)
            multfactor *= 33

