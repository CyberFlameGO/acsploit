from z3 import *
from options import Options


f = None
n = -1
options = Options()
options.add_option('n_collisions', 10, 'Number of collisions to create')
options.add_option('length', 10, 'Length of desired unhashed strings')
options.add_option('hash_table_size', 100, 'Size of target hash table')
options.add_option('target', 0, 'Desired hash value')


def run(self, generator, output):
    ret = self.get_collisions(str(self.options['target']), self.options['length'],
                       self.options['n_collisions'], self.options['hash_table_size'])
    output.output(ret)

def z3hash(self, bytes, hash_table_size):  # Example hash function. This can be any simple arithmetic hash
    return self.z3fletcher(bytes, hash_table_size)

def z3fletcher(self, bytes, hash_table_size):  # computes the z3form of the fletcher checksum
    v1 = 0
    v2 = 0
    for byte in bytes:
        v1 = v1 + z3.ZeroExt(24, byte) % hash_table_size
        v2 = v2 + v1 % hash_table_size
    return v2 + v1 % hash_table_size

def ascii_printable(self, x):
    return z3.And(0x20 <= x, x <= 0x7f)  # enforces that byte is printable ascii

def generate_ascii_printable_string(self, base_name, size, solver):
    # Establishes z3 variable names for bytes of the input string
    bytes = [z3.BitVec('%s%d' % (base_name, i), 8) for i in range(size)]
    # Adds the constraint that the bytes are printable ascii
    solver.add(z3.And(map(self.ascii_printable, bytes)))
    return bytes

def str_to_BitVecVals8(self,string):  # sets the target string into Z3 BitVecVals
    return map(
        lambda x: z3.BitVecVal(ord(x), 8),
        list(string)
    )

def get_collisions(self, target, length, n_collisions, hash_table_size):
    ret = []
    s = z3.Solver()
    # Houses the z3 variables for the potential hash match
    res = self.generate_ascii_printable_string('res', length, s)
    # enforces the z3 constraint that the hash matches the hash of the target string
    s.add(self.z3hash(res, hash_table_size) == self.z3hash(self.str_to_BitVecVals8(target), hash_table_size))
    count = 0
    # Z3 isn't stateful; you have to run it again and again while adding constraints to ignore previous solutions
    # TODO: what is the correct form of `sat` here? 'sat'? z3.sat? ???
    while s.check() == sat and count < n_collisions:
        x = s.model()  # This is a Z3 solution
        y = ''.join(chr(x[i].as_long()) for i in res[-length:])
        ret.append(y)  # print the solution
        count += 1
        # TODO: Change this to eval at some point, should iterate over all positions, not just the first three
        s.add(z3.Or(res[0] != x[res[-length+0]], res[1] != x[res[-length+1]], res[2] != x[res[-length+2]]))
        if count >= n_collisions:
            return ret # Exit after you have enough collisions
    # raises this exception when you can't find any more solutions. TODO: change this to be more elegant?
    raise Exception('Unsat!')

