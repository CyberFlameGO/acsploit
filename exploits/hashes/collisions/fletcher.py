import z3
from options import Options


options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('length', 10, 'Length of strings to create')
options.add_option('hash_table_size', 100, 'Size of target hash table')
options.add_option('width', 16, 'Bit-width of Fletcher checksum', [16, 32, 64])
options.add_option('target', 'hello', 'Preimage of desired hash value')

DESCRIPTION = 'Produces hash collisions for the fletcher checksum function'


def run(generator, output):
    ret = get_collisions(options['target'], options['length'], options['n_collisions'], options['hash_table_size'],
                         (2**(options['width']/2))-1)  # eg, fletcher16 => 255
    output.output(ret)


def z3fletcher(bytes, hash_table_size, modulus):  # computes the z3form of the fletcher checksum
    v1 = 0
    v2 = 0
    for byte in bytes:
        v1 = (v1 + z3.ZeroExt(24, byte)) % modulus
        v2 = (v2 + v1) % modulus
    return (v2 * (modulus+1) + v1) % hash_table_size


def ascii_printable(x):
    return z3.And(0x20 <= x, x <= 0x7e)  # enforces that byte is printable ascii


def generate_ascii_printable_string(base_name, size, solver):
    # Establishes z3 variable names for bytes of the input string
    bytes = [z3.BitVec('%s%d' % (base_name, i), 8) for i in range(size)]
    # Adds the constraint that the bytes are printable ascii
    solver.add(z3.And([ascii_printable(byte) for byte in bytes]))
    return bytes


def str_to_BitVecVals8(string):  # sets the target string into Z3 BitVecVals
    return [z3.BitVecVal(ord(x), 8) for x in string]


def get_collisions(target, length, n_collisions, hash_table_size, modulus):
    ret = []
    s = z3.Solver()
    # Houses the z3 variables for the potential hash match
    res = generate_ascii_printable_string('res', length, s)
    # enforces the z3 constraint that the hash matches the hash of the target string
    s.add(z3fletcher(res, hash_table_size, modulus) == z3fletcher(str_to_BitVecVals8(target), hash_table_size, modulus))
    count = 0
    # z3 isn't stateful; you have to run it again and again while adding constraints to ignore previous solutions
    while s.check() == z3.sat and count < n_collisions:
        x = s.model()  # This is a z3 solution
        y = ''.join(chr(x[i].as_long()) for i in res)
        ret.append(y)  # print the solution
        count += 1
        # add constraints
        s.add(z3.Or([r != x[r] for r in res]))
        if count >= n_collisions:
            return ret  # Exit after you have enough collisions
    # raises this exception when you can't find any more solutions
    raise ValueError('Could not find enough solutions')
