from itertools import product
from options import Options


options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('hash_table_size', 100, 'Size of target hash table')
options.add_option('target_type', 'preimage', 'Whether the target is an image (hash output) or preimage (hash input)',
                   ['image', 'preimage'])
options.add_option('target', 'hello', 'Image or preimage of desired hash value')

DESCRIPTION = 'Produces hash collisions for the Java hash function'

DEFAULT_INPUT = 'char'


def run(generator, output):
    forbidden_string = ''
    if options['target_type'] == 'preimage':
        target = java_hash(options['target'], options['hash_table_size'])
        forbidden_string = options['target']
    else:
        target = int(options['target'])

    ret = generate_java_preimages(generator, target, options['n_collisions'],
                                  options['hash_table_size'], forbidden_string)
    output.output(ret)


def java_hash(inputstring, hash_table_size):
    result = 0
    n = len(inputstring)
    for i in range(0, n):
        result += 31 ** (n-1-i) * ord(inputstring[i])
    result %= 2**32
    return result % hash_table_size


def generate_java_hash_strings(generator, half_length, hash_table_size):
    keys = {}
    characters = generator.get_char_set()
    for i in product(characters, repeat=half_length):
        hash_val = java_hash(i, hash_table_size)
        keys[hash_val] = keys.get(hash_val, [])  # create list if it doesn't exist
        keys[hash_val].append(''.join(i))
    return keys


def generate_java_preimages(generator, target, collisions, hash_table_size, forbidden_string):
    length = 6  # starting at length 1 is a bad idea; length 6 seems reasonable, but this is pretty arbitrary
    ret = []

    while len(ret) < collisions:
        multfactor = 31 ** (length // 2)
        keys = generate_java_hash_strings(generator, length // 2, hash_table_size)
        otherkeys = keys
        if length % 2 != 0:
            keys = generate_java_hash_strings(generator, 1 + length // 2, hash_table_size)

        for subhash in keys:
            effective_target = (target - (subhash * multfactor)) % hash_table_size
            if effective_target in otherkeys:
                substrings = keys[subhash]
                poststrings = otherkeys[effective_target]
                ret.extend([s+p for s in substrings for p in poststrings if s+p != forbidden_string])
                if len(ret) >= collisions:
                    break
        length += 1

    ret.sort()
    return ret[:collisions]
