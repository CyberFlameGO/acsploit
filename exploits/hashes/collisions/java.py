from itertools import product
from options import Options


options = Options()
options.add_option('n_collisions', 10, 'Number of collisions to create')
options.add_option('target', 0, 'Desired hash value')
options.add_option('length', 10, 'Length of desired unhashed strings')
options.add_option('hash_table_size', 100, 'Size of target hash table')

DESCRIPTION = 'Produces hash collisions for the Java hash function'


def run(generator, output):
    ret = generate_java_preimages(generator, options['target'], options['n_collisions'])
    output.output(ret)


def java_hash(inputstring):
    result = 0
    n = len(inputstring)
    for i in range(0, n):
        result += 31 ** (n-i) * ord(inputstring[i])
    return result % (2**32)


def generate_java_hash_strings(generator, halflength):
    keys = {}
    # TODO: test the types directly, not via __name__
    if type(generator).__name__ == 'CharGenerator':
        characters = generator.get_char_set()
    elif type(generator).__name__ == 'IntGenerator':
        characters = list(range(generator.get_min_value(), generator.get_max_value()))
    elif type(generator).__name__ == 'StringGenerator':
        characters = generator.char_gen.characters
    else:
         characters = []
    for i in product(characters, repeat=halflength):  # This only does uppercase letters, TODO: allow other input
        keys[java_hash(i)] = ''.join(i)
    return keys


def generate_java_preimages(generator, target, collisions):
    length = 1  # We don't often find small collisions, we can start at length 6.
    current = 0
    ret = []
    while current < collisions:
        if length % 2 == 0:
            multfactor = 31 ** (length / 2)
            keys = generate_java_hash_strings(generator, int(length/2))
            for subhash, substring in keys.items():
                effectiveTarget = (target-(subhash * multfactor)) % (2 ** 32)
                if effectiveTarget in keys:
                    poststring = keys.get(effectiveTarget)
                    ret.append(substring+poststring)
                    current += 1
                    if current >= collisions:
                        break
            length += 1
        else:
            multfactor2 = 31 ** ((length-1)/2)
            keys = generate_java_hash_strings(generator, int((length+1)/2))
            otherkeys = generate_java_hash_strings(generator, int((length-1)/2))
            for subhash, substring in keys.items():
                effectiveTarget = (target - (subhash * multfactor2)) % (2 ** 32)
                if effectiveTarget in otherkeys:
                    poststring = otherkeys.get(effectiveTarget)
                    ret.append(substring+poststring)
                    current += 1
                    if current >= collisions:
                        break
            length += 1
    return ret
