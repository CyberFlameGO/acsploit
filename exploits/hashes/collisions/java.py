from itertools import product

class java():
    f = None
    n = -1
    options = {
        'n_collisions': 10,
        'target': 0,
        'length': 10,
        'hash_table_size': 100}

    descriptions = {
        'n_collisions': 'Number of collisions to create.',
        'target': 'Desired hash value.',
        'length': 'Length of desired unhashed strings.',
        'hash_table_size': 'Size of target hash table.'}

    def run(self, generator):
        self.GenerateJavaPreimages(generator, self.options['target'], int(self.options['n_collisions']))

    def JavaHash(self, inputstring):
        result = 0
        n = len(inputstring)
        for i in range(0, n):
            result += 31 ** (n-i) * ord(inputstring[i])
        return result % (2**32)
    
    def GenerateJavaHashStrings(self, generator, halflength):
        keys = {}
        if type(generator).__name__ == 'CharGenerator':
            characters = generator.characters
        elif type(generator).__name__ == 'IntGenerator':
            characters = range(generator.get_min_value(), generator.get_max_value())
        elif type(generator).__name__ == 'StringGenerator':
            characters = generator.char_gen.characters
        else:
             characters = []
        for i in product(characters, repeat=halflength):  # This only does uppercase letters, TODO: allow other input
            keys[self.JavaHash(i)] = ''.join(i)
        return keys
    
    def GenerateJavaPreimages(self,generator, target, collisions): 
        length = 1  # We don't often find small collisions, we can start at length 6.
        current = 0
        while current < collisions:
            if length % 2 == 0:
                multfactor = 31 ** (length / 2)
                keys = self.GenerateJavaHashStrings(generator, int(length/2))
                for subhash, substring in keys.iteritems():
                    effectiveTarget = (target-(subhash * multfactor)) % (2 ** 32)
                    if effectiveTarget in keys:
                        poststring = keys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if current >= collisions:
                            break
                length += 1
            else:
                multfactor2 = 31 ** ((length-1)/2)
                keys = self.GenerateJavaHashStrings(generator, int((length+1)/2))
                otherkeys = self.GenerateJavaHashStrings(generator, int((length-1)/2))
                for subhash, substring in keys.iteritems():
                    effectiveTarget = (target - (subhash * multfactor2)) % (2 ** 32)
                    if effectiveTarget in otherkeys:
                        poststring = otherkeys.get(effectiveTarget)
                        print(substring+poststring)
                        current += 1
                        if current >= collisions:
                            break
                length += 1
