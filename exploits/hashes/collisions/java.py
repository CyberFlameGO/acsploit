import itertools
from options import Options


options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('hash_table_size', 2**32, 'Size of target hash table')
options.add_option('target_type', 'preimage', 'Whether the target is an image (hash output) or preimage (hash input)',
                   ['image', 'preimage'])
options.add_option('target', 'hello', 'Image or preimage of desired hash value')

DESCRIPTION = 'Produces hash collisions for the Java hash function'

DEFAULT_INPUT = 'char'


def run(generator, output):
    forbidden_string = ''
    if options['target_type'] == 'preimage':
        target = java_hash(options['target'], options['hash_table_size'])
        forbidden_string = options['target']
    else:
        target = int(options['target'])

    ret = generate_java_preimages(generator, target, options['n_collisions'],
                                  options['hash_table_size'], forbidden_string)
    output.output(ret)


def java_hash(inputstring, hash_table_size):
    result = 0
    n = len(inputstring)
    for i in range(0, n):
        result += 31 ** (n-1-i) * ord(inputstring[i])
    result %= 2**32
    return result % hash_table_size


def generate_java_hash_strings(generator, half_length, hash_table_size):
    keys = {}
    characters = generator.get_char_set()
    for s in itertools.product(characters, repeat=half_length):
        hash_val = java_hash(s, hash_table_size)
        keys[hash_val] = ''.join(s)
    return keys


def generate_java_preimages(generator, target, collisions, hash_table_size, forbidden_string):
    length = 6  # starting at length 1 is a bad idea; length 6 seems reasonable, but this is pretty arbitrary
    pre_keys = generate_java_hash_strings(generator, 3, hash_table_size)
    post_keys = pre_keys
    multfactor = 31 ** 3  # should always equal 31 ** length of post_strings in post_keys
    ret = []

    while True:
        for pre_hash in pre_keys:
            effective_target = (target - (pre_hash * multfactor)) % hash_table_size
            if effective_target in post_keys:
                pre_string = pre_keys[pre_hash]
                post_string = post_keys[effective_target]
                if pre_string + post_string != forbidden_string:
                    ret.append(pre_string + post_string)

                if len(ret) >= collisions:
                    ret.sort()
                    return ret

        # Update variables for next loop

        length += 1
        pre_keys = post_keys  # pre_keys follows 1 step behind post_keys
        if length % 2 != 0:
            # we update to a longer post_keys at every odd length
            post_keys = generate_java_hash_strings(generator, 1 + length // 2, hash_table_size)
            multfactor *= 31

