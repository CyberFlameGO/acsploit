from itertools import product
from options import Options


options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('hash_table_size', 100, 'Size of target hash table')
options.add_option('target', 0, 'Target hash value')

DESCRIPTION = 'Produces hash collisions for the Java hash function'


def run(generator, output):
    if generator.INPUT_NAME != 'char':
        raise ValueError('Input generator must be character')
    ret = generate_java_preimages(generator, options['target'], options['n_collisions'], options['hash_table_size'])
    output.output(ret)


def java_hash(inputstring, hash_table_size):
    result = 0
    n = len(inputstring)
    for i in range(0, n):
        result += 31 ** (n-1-i) * ord(inputstring[i])
    return result % hash_table_size


def generate_java_hash_strings(generator, half_length, hash_table_size):
    keys = {}
    characters = generator.get_char_set()
    for i in product(characters, repeat=half_length):
        hash_val = java_hash(i, hash_table_size)
        keys[hash_val] = keys.get(hash_val, [])  # create list if it doesn't exist
        keys[hash_val].append(''.join(i))
    return keys


def generate_java_preimages(generator, target, collisions, hash_table_size):
    length = 6  # starting at length 1 is a bad idea; length 6 seems reasonable, but this is pretty arbitrary
    ret = []

    while len(ret) < collisions:
        multfactor = 31 ** (length // 2)
        keys = generate_java_hash_strings(generator, length // 2, hash_table_size)
        otherkeys = keys
        if length % 2 != 0:
            keys = generate_java_hash_strings(generator, 1 + length // 2, hash_table_size)

        for subhash in keys:
            effective_target = (target - (subhash * multfactor)) % hash_table_size
            if effective_target in otherkeys:
                substrings = keys[subhash]
                poststrings = otherkeys[effective_target]
                ret.extend([s+p for s in substrings for p in poststrings])
                if len(ret) >= collisions:
                    break
        length += 1

    return ret[:collisions]
