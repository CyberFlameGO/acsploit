import z3
from options import Options
from .z3_common import get_collisions


# TODO: rename to crc32

options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('length', 10, 'Length of strings to create')
options.add_option('hash_table_size', 0xffffffff, 'Size of target hash table')
options.add_option('target_type', 'preimage', 'Whether the target is an image (hash output) or preimage (hash input)',
                   ['image', 'preimage'])
options.add_option('target', 'hello', 'Image or preimage of desired hash value')

DESCRIPTION = 'Produces hash collisions for the CRC-32 checksum function'

NO_INPUT = True


def run(output):
    ret = get_collisions(z3crc32, options['target'], options['target_type'], options['length'],
                         options['n_collisions'], options['hash_table_size'])
    output.output(ret)


def z3crc32(bytes, hash_table_size):  # computes the crc32 checksum in z3 format
    checksum = 0xffffffff
    for byte in bytes:
        checksum ^= z3.ZeroExt(24, byte) & 0xff
        for _ in range(8):  # test each bit in the byte we just xor'd in
            checksum = z3.If(checksum & 1 == z3.BitVecVal(1, 32),
                             z3.LShR(checksum, 1) ^ 0xedb88320,  # the binary representation of the CRC-32 polynomial
                             z3.LShR(checksum, 1))
    return checksum ^ 0xffffffff  # TODO: why does adding `% hash_table_size` break this?


def z3bsd(bytes, hash_table_size):  # computes the bsd checksum in z3 format.
    checksum = 0xffffffff
    for byte in bytes:
        checksum = (checksum >> 1) + ((checksum & 1) << 15)
        checksum += z3.ZeroExt(24, byte)
        checksum &= 0xffff
    return checksum % hash_table_size
