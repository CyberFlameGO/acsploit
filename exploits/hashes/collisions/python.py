import random
from options import Options

options = Options()
options.add_option('n_collisions', 10, 'Number of colliding strings to create')
options.add_option('length', 10, 'Length of strings to create')
options.add_option('n_substrings', 10_000_000, 'Number of hash substrings to use')
options.add_option('hash_table_size', 2**32, 'Size of target hash table')
options.add_option('target_type', 'preimage', 'Whether the target is an image (hash output) or preimage (hash input)',
                   ['image', 'preimage'])
options.add_option('target', 'hello', 'Image or preimage of desired hash value')

DESCRIPTION = 'Produces hash collisions for the 32-bit Python 2 string hash function'  # TODO: longer description

DEFAULT_INPUT = 'char'

SUBSTRING_LEN = 4


def run(generator, output):
    # given a target hash and string length
    # generate random strings of three characters and reverse them out of the hash value
    # make a lookup table from the resulting semi-hash values to the strings
    # generate random strings of length - 3 characters and partially hash them
    # if the result is in the hash table, concat the three chars there onto the end of the string to get a collision
    # a meet-in-the-middle brute force attack!
    if options['target_type'] == 'preimage':
        target = hash(options['target'])
    else:
        target = options['target']

    target_length = options['length']
    forward_length = target_length - SUBSTRING_LEN
    if forward_length <= 0:
        raise ValueError('length must be greater than %i' % SUBSTRING_LEN)  # TODO: make SUBSTRING_LEN settable?

    table = hash_backwards(target, generator, options['length'], options['n_substrings'], chars=SUBSTRING_LEN)
    collisions = hash_forwards(options['n_collisions'], forward_length, generator, table)

    output.output(collisions)


def hash(preimage):
    x = ord(preimage[0]) << 7
    for char in preimage:
        x = (1_000_003 * x) ^ ord(char)
        x %= 2**64
    x ^= len(preimage)
    return x


# partial_len must equal preimage_len - chars in the call to hash_backwards() used to build lookup_table
def hash_forwards(n_collisions, partial_len, generator, lookup_table):
    characters = generator.get_char_set()

    collisions = []

    while len(collisions) < n_collisions:
        partial_preimage = ''.join(characters for _ in range(partial_len))

        semi_hash = hash(partial_preimage) ^ partial_len  # undo the XOR, as it's included in the table value
        if semi_hash in lookup_table:
            collisions.append(partial_preimage + lookup_table[semi_hash])

    return collisions


def hash_backwards(target, generator, preimage_len, table_size, chars=3):
    # 'reverse' the given number of characters out of the target hash
    # uses random characters and returns a table from the semi-computed hashes
    # to the generated strings of characters
    table = {}

    characters = generator.get_char_set()

    for _ in range(table_size):  # TODO: change this to use all permutations and control table size by length of string?
        semi_hash = target
        string = ''.join(random.choice(characters) for _ in range(chars))

        # XOR out the length
        semi_hash ^= preimage_len
        # undo each character
        for char in reversed(string):
            semi_hash ^= ord(char)
            semi_hash *= 2021759595  # ring inverse of 1_000_003 % 2 ** 32
            semi_hash %= 2**32

        table[semi_hash] = string

    return table
