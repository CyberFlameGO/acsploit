# TODO: Fix weighted, undirected graph

class kruskal():

    options = {
        'directed': False,
        'weighted': False,
        'n_inputs': 10}
    descriptions = {
        'directed': 'True or False.',
        'weighted': 'True or False',
        'n_inputs': 'Number of nodes in graph.'}

    def run(self, generator):
        directed = False
        if isinstance(self.options['directed'], bool) and self.options['directed']:
            directed = True
        if isinstance(self.options['directed'], str) and self.options['directed'].lower() == 'true':
            directed = True

        if isinstance(self.options['weighted'], bool) and self.options['weighted'] is True:
            print self.kruskal(generator, int(self.options['n_inputs']), directed)
        elif isinstance(self.options['weighted'], str) and self.options['weighted'].lower() == 'true':
            print self.kruskal(generator, int(self.options['n_inputs']), directed)

    def kruskal(self, generator, n_inputs, directed):
        G = {}
        weight = 1  # Should be minimum positive value, but 1 seems unlikely to be outside range
        possible_nodes = []
        n = generator.get_min_value()
        if type(generator.get_min_value) == int:
            n = 0  # Avoid obnoxious int names
        for i in range(n_inputs):
            possible_nodes.append(n)
            n = generator.get_greater_than(n)
        for i in range(n_inputs):
            G[possible_nodes[i]] = []
            for n in range(n_inputs):
                if not directed:
                    # print((possible_nodes[n], weight))
                    # print(G[possible_nodes[i]])
                    if (possible_nodes[i], weight) not in G[possible_nodes[n]]:
                        G[possible_nodes[i]].append((possible_nodes[n], weight))
                else:
                    G[possible_nodes[i]].append((possible_nodes[n], weight))
        formatted_output = ''
        for node in G:
            formatted_output += (str(node) + ': ')
            first = True
            for connection in G[node]:
                if first:
                    formatted_output += str(connection)
                    first = False
                else:
                    formatted_output += (', ' + str(connection))
            formatted_output += '\n'
        G = formatted_output

        return G
