#!/usr/bin/env python
import sys
from z3 import *
# -*- coding: utf-8 -*-

#
#    hash_collisions_z3.py - Using z3py to satisfy a bunch of constraints involving
#    a non-cryptographic hashing algorithm.
#    Copyright (C) 2013 Axel "0vercl0k" Souchet - http://www.twitter.com/0vercl0k
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

def hash(bytes, hash_table_size): #Example hash function 
    h = 0
    for byte in bytes:
        h = h * 31 + z3.ZeroExt(24,byte) # Does the hash byte by byte (can easily change the logic here)
    return h % hash_table_size #mods out by hash table size

def ascii_printable(x):
    '''Adds the constraints to have an ascii printable byte'''
    return z3.And(0x20 <= x, x <= 0x7f)

def generate_ascii_printable_string(base_name, size, solver):
    '''Generates a sequence of byte you can use as something to simulate C strings,
    and also adds to the solver the required constraints to have an ascii printable string'''
    bytes = [z3.BitVec('%s%d' % (base_name, i), 8) for i in range(size)]
    solver.add(z3.And(map(ascii_printable, bytes)))
    return bytes

def str_to_BitVecVals8(s):
    '''Generates a list of BitVecVal8 from a python string'''
    return map(
        lambda x: z3.BitVecVal(ord(x), 8),
        list(s)
    )

def getcollisions(target, length,n_collisions, hash_table_size):
    s = z3.Solver()
    res = generate_ascii_printable_string('res',length,s)
    s.add(hash(res, hash_table_size) == hash(str_to_BitVecVals8(target), hash_table_size))
    count=0
    while s.check() == sat and count<n_collisions:
        x = s.model() 
        y= ''.join(chr(x[i].as_long()) for i in res[-length:])
        print y
        count=count+1
        s.add(z3.Or(res[0] !=x[res[-length+0]], res[1]!=x[res[-length+1]], res[2] !=x[res[-length+2]]))  #Change this to eval at some point, should iterate over all positions, not just the first three  
        if count >= n_collisions:
            return
    raise Exception('Unsat!')

def main(argc, argv):
    string="Hello World"
    length=10
    n_collisions=100
    hash_table_size=30
    getcollisions(string, length, n_collisions, hash_table_size)

if __name__ == '__main__':
    sys.exit(main(len(sys.argv), sys.argv))
