#!/usr/bin/env python
import sys
from z3 import *
# -*- coding: utf-8 -*-

#
#    hash_collisions_z3.py - Using z3py to satisfy a bunch of constraints involving
#    a non-cryptographic hashing algorithm.
#    Copyright (C) 2013 Axel "0vercl0k" Souchet - http://www.twitter.com/0vercl0k
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

def hash(bytes): #Example hash function 
    h = 0
    for byte in bytes:
        h = h * 31 + ZeroExt(24,byte)
    return h % 32

def ascii_printable(x):
    '''Adds the constraints to have an ascii printable byte'''
    return And(0x20 <= x, x <= 0x7f)

def generate_ascii_printable_string(base_name, size, solver):
    '''Generates a sequence of byte you can use as something to simulate C strings,
    and also adds to the solver the required constraints to have an ascii printable string'''
    bytes = [BitVec('%s%d' % (base_name, i), 8) for i in range(size)]
    solver.add(And(map(ascii_printable, bytes)))
    return bytes

def str_to_BitVecVals8(s):
    '''Generates a list of BitVecVal8 from a python string'''
    return map(
        lambda x: BitVecVal(ord(x), 8),
        list(s)
    )

def getcollisions(target, size,n_collisions):
    s = Solver()
    res = generate_ascii_printable_string('res',size,s)
    print res[0]
    s.add(hash(res) == hash(str_to_BitVecVals8(target)))
    count=0
    while s.check() == sat: # and count<n_collisions:
        x = s.model() 
        y= ''.join(chr(x[i].as_long()) for i in res[-size:])
        print y
        count=count+1
        res0=res[0]
        s.add(res0 !=x[res[-size]])
        if count>= n_collisions:
            return
    raise Exception('Unsat!')

def main(argc, argv):
    a="Hello World"
    getcollisions(a, 11, 100)

if __name__ == '__main__':
    sys.exit(main(len(sys.argv), sys.argv))
