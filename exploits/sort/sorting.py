class SortExploit():

    options = {
        'type': 'insertionsort',
        'n_inputs': 10}
    descriptions = {
        'type': 'One of insertionsort, bubblesort, mergesort, quicksortlomuto, quicksorthoare, or quicksortmid.',
        'n_inputs': 'Number of elements to sort.'}

    def run(self, generator):
        if self.options['type'] == 'bubblesort' or self.options['type'] == 'insertionsort':
            # Bubblesort and insertion sort worst case is reverse ordered
            print self.descending_list(generator, int(self.options['n_inputs']))
        elif self.options['type'] == 'mergesort':
            # Worst case for mergesort is a 'separated' list causing maximum comparisons
            print self.separated_list(generator, int(self.options['n_inputs']))
        elif self.options['type'] == 'quicksortlomuto' or self.options['Type'] == 'quicksorthoare':
            # Worst case for Lomuto and Hoare quicksort is already sorted.
            print self.ascending_list(generator, int(self.options['n_inputs']))
        elif self.options['type'] == 'quicksortmid':
            # worst case for quicksort with midpoint pivots radiates from the center
            print self.radiate_list(generator, int(self.options['n_inputs']))

    def ascending_list(self, generator, n_inputs):
        return list(reversed(self.descending_list(generator, n_inputs)))

    def descending_list(self, generator, n_inputs):
        output = [generator.get_random()]  # pick random value for now, need to check range in future

        for i in range(1, n_inputs):
            output.append(generator.get_less_than(output[i-1]))     

        return output

    def radiate_list(self, generator, n_inputs):
        # generates the worst case list for quicksort with midpoint pivots (rounded to the left)
        reverseorderedlist = self.descending_list(generator, n_inputs)  # Start with a reverse-sorted list
        output = [None] * len(reverseorderedlist)
        k = len(reverseorderedlist)-1
        print(k)
        for i in range(0, len(reverseorderedlist)):
            if i % 2 == 0:
                output[int(k-(i/2))] = reverseorderedlist[i]
            else:
                output[int((i-1)/2)] = reverseorderedlist[i]
        return output

    def separated_list(self, generator, n_inputs):
        sortedlist = self.ascending_list(generator, n_inputs)  # Start with a sorted list
        
        self.separate(sortedlist)  # manipulates it in place
        
        return sortedlist

    def merge(self, list, left, right):  # builds 'list' from left and right
        for i in range(len(left)):
            list[i] = left[i]
        for j in range(len(right)):
            list[len(left)+j] = right[j]
    
    def separate(self, list):  # produces worst case for mergesort from sorted list
        if len(list) < 2:
            return
        if len(list) == 2:
            swap = list[0]
            list[0] = list[1]
            list[1] = swap
            return
        right = list[1::2]
        left = list[0::2]
        self.separate(left)
        self.separate(right)        
        self.merge(list, left, right)
