from options import Options


options = Options()
options.add_option('n_inputs', 10, 'Number of elements to sort')


def run(generator, output):
    # Worst case for mergesort is a 'separated' list causing maximum comparisons
    output.output(separated_list(generator, options['n_inputs']))

def ascending_list(generator, n_inputs):
    return list(reversed(descending_list(generator, n_inputs)))


def descending_list(generator, n_inputs):
    output = [generator.get_random()]  # pick random value for now, need to check range in future

    for i in range(1, n_inputs):
        output.append(generator.get_less_than(output[i-1]))

    return output


def separated_list(generator, n_inputs):
    sortedlist = ascending_list(generator, n_inputs)  # Start with a sorted list

    separate(sortedlist)  # manipulates it in place

    return sortedlist


def merge(list, left, right):  # builds 'list' from left and right
    for i in range(len(left)):
        list[i] = left[i]
    for j in range(len(right)):
        list[len(left)+j] = right[j]


def separate(list):  # produces worst case for mergesort from sorted list
    if len(list) < 2:
        return
    if len(list) == 2:
        swap = list[0]
        list[0] = list[1]
        list[1] = swap
        return
    right = list[1::2]
    left = list[0::2]
    separate(left)
    separate(right)
    merge(list, left, right)
