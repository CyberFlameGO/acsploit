from options import Options
import itertools
import copy
from . import regex_common
import string
import os

options = Options()
options.add_option('regex', 'your_regex', 'Regex to exploit, if vulnerable')
options.add_option('regex_file', 'your_file', 'File containing newline separated regex expressions to exploit')
options.add_option('use_file', False, 'Whether to use the file of regex expressions or the single user supplied expression')
options.add_option('max_length', 25, 'Maximum size of exploit string, if regex is vulnerable')
options.add_option('show_nfa', False, 'Whether to show the parsed NFA graph (for debugging), cannot be used with file')
options.add_option('include_quadratic', False, 'Whether to include quadratic runtime vulnerabilities. May take awhile')

DESCRIPTION = 'Exploits regex that are vulnerable to catastrophic backtracking (ReDoS).' \
              '\n\n  ' \
              'Given a regex, it is first checked to see if it is vulnerable to ReDoS attack. There are two checks: ' \
              'if it is vulnerable to an exponential attack, or a quadratic attack. Exponential attacks have a much ' \
              'more significant effect with a shorter string length, whereas a quadratic attack likely needs a larger ' \
              'string length to have an effect. Once it is determined that a regex is vulnerable, a string is output ' \
              'that when matched against the regex, will result in a large amount of resources needed to determine if ' \
              'the string matches (and will likely never finish). The larger the exploit string length, the longer this ' \
              'will take. Algorithms used are from "Static Detection of DoS Vulnerabilities in Programs that use Regular ' \
              'Expressions", by Wustholz, Olivo, Heule, and Dillig. As a warning, searching for quadratic attacks is ' \
              'very inefficient and can take quite a while.'
NO_INPUT = True

def next_state(nfa):
    # This could be improved but it seems that the next state is always
    # available so the loop doesn't occur that much if at all
    state = len(nfa['states'])
    while state in nfa['states']:
        state += 1
    return state

def nfa_intersection_handle_epsilon_edges(intersection, nfa_1, nfa_2, state_nfa_1,
                                          state_nfa_2, boundary):
    current_state = (state_nfa_1, state_nfa_2)
    for (d1, t1) in nfa_1['transitions'].get(state_nfa_1, {}).items():
        if not t1.is_epsilon():
            continue
        next_state = (d1, state_nfa_2)
        if next_state not in intersection['states']:
            intersection['states'].add(next_state)
            boundary.add(next_state)
        intersection['transitions'].setdefault(current_state, {})[
            next_state] =  regex_common.Transition(epsilon=True)
        if d1 in nfa_1['accepting_states'] and state_nfa_2 in nfa_2['accepting_states']:
            intersection['accepting_states'].add(next_state)

    for (d2, t2) in nfa_2['transitions'].get(state_nfa_2, {}).items():
        if not t2.is_epsilon():
            continue
        next_state = (state_nfa_1, d2)
        if next_state not in intersection['states']:
            intersection['states'].add(next_state)
            boundary.add(next_state)
        intersection['transitions'].setdefault(current_state, {})[
            next_state] =  regex_common.Transition(epsilon=True)
        if state_nfa_2 in nfa_1['accepting_states'] and d2 in nfa_2['accepting_states']:
            intersection['accepting_states'].add(next_state)


# Taken from PySimpleAutomata and modified to support epsilon
def nfa_intersection(nfa_1, nfa_2):
    """ Returns a NFA that reads the intersection of the NFAs in
    input.
    Let :math:`A_1 = (Σ,S_1,S_1^0,ρ_1,F_1)` and :math:`A_2 =(Σ,
    S_2,S_2^0,ρ_2,F_2)` be two NFAs.
    There is a NFA :math:`A_∧` that runs simultaneously both
    :math:`A_1` and :math:`A_2` on the input word,
    so :math:`L(A_∧) = L(A_1)∩L(A_2)`.
    It is defined as:
    :math:`A_∧ = ( Σ , S , S_0 , ρ , F )`
    where
    • :math:`S = S_1 × S_2`
    • :math:`S_0 = S_1^0 × S_2^0`
    • :math:`F = F_1 × F_2`
    • :math:`((s,t), a, (s_X , t_X)) ∈ ρ` iff :math:`(s, a,s_X )
      ∈ ρ_1` and :math:`(t, a, t_X ) ∈ ρ_2`
    :param dict nfa_1: first input NFA;
    :param dict nfa_2: second input NFA;
    :return: *(dict)* representing the intersected NFA.
    """
    intersection = {
        'states': set(),
        'initial_states': set(),
        'accepting_states': set(),
        'transitions': dict()
    }

    for init_1 in nfa_1['initial_states']:
        for init_2 in nfa_2['initial_states']:
            intersection['initial_states'].add((init_1, init_2))

    intersection['states'].update(intersection['initial_states'])

    boundary = set()
    boundary.update(intersection['initial_states'])
    while len(boundary) != 0:
        current_state = (state_nfa_1, state_nfa_2) = boundary.pop()
        if (state_nfa_1 in nfa_1['accepting_states'] and
            state_nfa_2 in nfa_2['accepting_states']):
            intersection['accepting_states'].add(current_state)

        nfa_intersection_handle_epsilon_edges(
            intersection, nfa_1, nfa_2, state_nfa_1, state_nfa_2, boundary)
        for (d_1, t1) in nfa_1['transitions'].get(state_nfa_1, {}).items():
            if t1.is_epsilon():
                continue
            for (d_2, t2) in nfa_2['transitions'].get(state_nfa_2, {}).items():
                if t2.is_epsilon():
                    continue
                intersection_transition = t1.intersection(t2)
                if intersection_transition is None:
                    continue
                next_state = (d_1, d_2)
                if next_state not in intersection['states']:
                    intersection['states'].add(next_state)
                    boundary.add(next_state)
                    if next_state in intersection['transitions'].setdefault(current_state, {}):
                        raise NotImplementedError('Need to handle merging transitions')
                    else:
                        intersection['transitions'][current_state][next_state] = intersection_transition
                if (d_1 in nfa_1['accepting_states'] and
                    d_2 in nfa_2['accepting_states']):
                    intersection['accepting_states'].add(next_state)


    return intersection


def get_potential_outgoing_tuples(state, nfa):
    results = []
    transitions = nfa['transitions'].get(state, {})
    targets = transitions.keys()
    for state_1, state_2 in itertools.product(targets, repeat=2):
        if state_1 != state_2:
            intersection_transition = transitions[state_1].intersection(transitions[state_2])
            if intersection_transition is not None:
                results.append((intersection_transition, state_1, state_2))
    return results


def get_any_loopback_nfa(nfa, state):
    new_state = next_state(nfa)
    new_states = copy.deepcopy(nfa['states'])
    new_states.add(new_state)
    new_transitions = copy.deepcopy(nfa['transitions'])
    new_transitions[new_state] = {}
    for dest, transition in nfa['transitions'].get(state, {}).items():
        new_transitions[new_state][dest] = copy.deepcopy(transition)
    return {
        'states': new_states,
        'transitions': new_transitions,
        'initial_states': set([new_state]),
        'accepting_states': set([state]),
    }


def get_loopback_nfa(nfa, target_state, transition, pseudo_start_state):
    new_state = next_state(nfa)
    new_states = copy.deepcopy(nfa['states'])
    new_states.add(new_state)
    new_transitions = copy.deepcopy(nfa['transitions'])
    new_transitions[new_state] = {}
    new_transitions[new_state][pseudo_start_state] = transition
    return {
        'states': new_states,
        'transitions': new_transitions,
        'initial_states': set([new_state]),
        'accepting_states': set([target_state]),
    }


def find_shortest_path(nfa):
    queue = [(next(iter(nfa['initial_states'])), [])]
    visited = set()
    while len(queue) > 0:
        node, transitions_list = queue.pop(0)
        if node in nfa['accepting_states']:
            return transitions_list
        for dest, transition in nfa['transitions'].get(node, {}).items():
            if dest in visited:
                continue
            new_transitions_list = copy.deepcopy(transitions_list)
            new_transitions_list.append(transition)
            queue.append((dest, new_transitions_list))
            visited.add(dest)
    return None


def stringify_result(result):
    start_pattern = [x.get_char() for x in result[0]]
    repeat_pattern = [x.get_char() for x in result[1]]

    return ''.join(start_pattern), ''.join(repeat_pattern)


def find_hyper_vulnerabilities_for_pivot(state, nfa):
    for (transition, state_1, state_2) in get_potential_outgoing_tuples(state, nfa):
        nfa_1 = get_loopback_nfa(nfa, state, transition, state_1)
        nfa_2 = get_loopback_nfa(nfa, state, transition, state_2)
        intersection_nfa = nfa_intersection(nfa_1, nfa_2)
        if len(intersection_nfa['accepting_states']) == 0:
            continue

        repeat_pattern = find_shortest_path(intersection_nfa)
        initial_nfa = copy.deepcopy(nfa)
        initial_nfa['accepting_states'] = set([state])
        start_pattern = find_shortest_path(initial_nfa)
        for c in string.printable:
            if c in nfa['transitions'].get(state, {}):
                if len(nfa['transitions'][state][c].union(nfa['accepting_states'])) == 0:
                    return start_pattern, repeat_pattern
            else:
                return start_pattern, repeat_pattern
    return None


def _find_quadratic_vulnerabilities_for_pivot(nfa, state, state_1, state_2, transition):
    nfa_1 = get_loopback_nfa(nfa, state, transition, state_1)
    nfa_p = {  # prefix NFA
        'states': copy.deepcopy(nfa['states']),
        'transitions': copy.deepcopy(nfa['transitions']),
        'initial_states': copy.deepcopy(nfa['initial_states']),
        'accepting_states': set([state])
    }
    for q in nfa['states']:
        new_state = next_state(nfa)
        transitions = copy.deepcopy(nfa['transitions'])
        transitions.setdefault(new_state, {})[state_2] = transition
        nfa_2 = {
            'states': nfa['states'].union(set([new_state])),
            'transitions': transitions,
            'initial_states': set([new_state]),
            'accepting_states': set([q])
        }
        nfa_3 = get_any_loopback_nfa(nfa, q)
        nfa_s = {  # eventually will be used for suffix
            'states': copy.deepcopy(nfa['states']),
            'transitions': copy.deepcopy(nfa['transitions']),
            'initial_states': set([q]),
            'accepting_states': copy.deepcopy(nfa['accepting_states'])
        }
        intersection_nfa = nfa_intersection(nfa_1, nfa_2)
        intersection_nfa = nfa_intersection(intersection_nfa, nfa_3)

        if len(intersection_nfa['accepting_states']) == 0:
            continue
        repeat_pattern = find_shortest_path(intersection_nfa)
        start_pattern = find_shortest_path(nfa_p)
        for c in string.printable:
            if c in nfa['transitions'].get(state, {}):
                if len(nfa['transitions'][state][c].union(nfa['accepting_states'])) == 0:
                    return start_pattern, repeat_pattern
            else:
                return start_pattern, repeat_pattern
    return None


def find_quadratic_vulnerabilities_for_pivot(state, nfa):
    for (transition, state_1, state_2) in get_potential_outgoing_tuples(state, nfa):
        result = _find_quadratic_vulnerabilities_for_pivot(nfa, state, state_1, state_2, transition)
        if result is not None:
            return result
    return None


def free_transition_to_state(nfa, state, dest, visited):
    for d, t in nfa['transitions'].get(state, {}).items():
        if not t.is_epsilon():
            continue
        if d == dest:
            return True
        if d in visited:
            continue
        visited.update([d])
        if free_transition_to_state(nfa, d, dest, visited):
            return True
    return False


def equivalent_to_accepting_state(state, nfa):
    for a in nfa['accepting_states']:
        if (free_transition_to_state(nfa, a, state, set()) or
            free_transition_to_state(nfa, state, a, set())):
            return True
    return False


def find_hyper_vulnerabilities(nfa):
    for q in nfa['states']:
        if equivalent_to_accepting_state(q, nfa):
            continue
        vuln = find_hyper_vulnerabilities_for_pivot(q, nfa)
        if vuln is not None:
            return stringify_result(vuln)

    return None


def find_quadratic_vulnerabilities(nfa):
    for q in nfa['states']:
        if equivalent_to_accepting_state(q, nfa):
            continue
        vuln = find_quadratic_vulnerabilities_for_pivot(q, nfa)
        if vuln is not None:
            return stringify_result(vuln)
    return None

def run_regex(regex, show_nfa, max_length):
    parser = regex_common.RegexParser()
    nfa = parser.run(regex)

    if show_nfa:
        regex_common.RegexParser.show_graph(nfa)

    vulnerable_pattern = find_hyper_vulnerabilities(nfa)
    if vulnerable_pattern is None and options['include_quadratic']:
        vulnerable_pattern = find_quadratic_vulnerabilities(nfa)
    if vulnerable_pattern is None:
        raise ValueError('Regex is not vulnerable to ReDoS attack')

    prefix, attack = vulnerable_pattern
    if len(prefix) + len(attack) > max_length:
        raise ValueError('Max length too small, cannot exploit regex')

    return prefix + (((max_length - len(prefix)) // len(attack)) * attack)

def run(output):

    if options['use_file']:
        with open(os.path.expanduser(options['regex_file'])) as f:
            results = []
            for line in f:
                if (len(line) > 0) and (line[-1] == '\n'):
                    line = line[:-1]

                if len(line) == 0:
                    continue
                try:
                    results.append((line, run_regex(line, False, options['max_length'])))
                except ValueError as e:
                    results.append((line, str(e)))
            output.output(results)
    else:
        output.output([run_regex(options['regex'], options['show_nfa'], options['max_length'])])
