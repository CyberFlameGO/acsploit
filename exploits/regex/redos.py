from options import Options
import itertools
import copy
from .regex_common import Automata
from . import regex_common
import string
import os
import progressbar
import multiprocessing as mp
import re
import time
from scipy.optimize import curve_fit

options = Options()
options.add_option('regex', 'your_regex', 'Regex to exploit, if vulnerable')
options.add_option('regex_file', 'your_file', 'File containing newline separated regular expressions to exploit')
options.add_option('use_file', False, 'Whether to use the file of regular expressions or the single user supplied expression')
options.add_option('show_progress_bar', False, 'Whether to show a progress bar showing how much of ' +
                   'the file has been processed, only valid when use_file is True')
options.add_option('show_only_vulnerable', True, 'Whether to show only the vulnerable regular expressions, only valid when use_file is True')
options.add_option('max_length', 25, 'Maximum size of exploit string, if regex is vulnerable')
options.add_option('show_nfa', False, 'Whether to show the parsed NFA graph (for debugging), cannot be used with file')
options.add_option('include_quadratic', False, 'Whether to include quadratic runtime vulnerabilities. May take awhile')
options.add_option('verify', False, 'Verifies the attack strings are correct')
options.add_option('parallelize', True, 'Process the regex in a file in parallel')

DESCRIPTION = 'Exploits regex that are vulnerable to catastrophic backtracking (ReDoS).' \
              '\n\n  ' \
              'Given a regex, it is first checked to see if it is vulnerable to ReDoS attack. There are two checks: ' \
              'if it is vulnerable to an exponential attack, or a quadratic attack. Exponential attacks have a much ' \
              'more significant effect with a shorter string length, whereas a quadratic attack likely needs a larger ' \
              'string length to have an effect. Once it is determined that a regex is vulnerable, a string is output ' \
              'that when matched against the regex, will result in a large amount of resources needed to determine if ' \
              'the string matches (and will likely never finish). The larger the exploit string length, the longer this ' \
              'will take. Algorithms used are from "Static Detection of DoS Vulnerabilities in Programs that use Regular ' \
              'Expressions", by Wustholz, Olivo, Heule, and Dillig. As a warning, searching for quadratic attacks is ' \
              'very inefficient and can take quite a while.'
NO_INPUT = True

def get_potential_outgoing_tuples(state, nfa):
    results = []
    transitions = nfa.get_transitions(state)
    targets = transitions.keys()
    for state_1, state_2 in itertools.product(targets, repeat=2):
        if state_1 != state_2:
            intersection_transition = transitions[state_1].intersection(transitions[state_2])
            if intersection_transition is not None:
                results.append((intersection_transition, state_1, state_2))
    return results


def get_any_loopback_nfa(nfa, state):
    new_state = nfa.get_new_state()
    new_states = nfa.copy_states()
    new_states.add(new_state)
    new_transitions = nfa.copy_transitions()
    new_transitions[new_state] = {}
    for dest, transition in nfa.get_transitions(state).items():
        new_transitions[new_state][dest] = copy.deepcopy(transition)
    return Automata(new_states, new_state, new_transitions, set([state]),
                    nfa.start_anchor, nfa.end_anchor, nfa.deterministic)


def get_loopback_nfa(nfa, target_state, transition, pseudo_start_state):
    new_state = nfa.get_new_state()
    new_states = nfa.copy_states()
    new_states.add(new_state)
    new_transitions = nfa.copy_transitions()
    new_transitions[new_state] = {}
    new_transitions[new_state][pseudo_start_state] = transition
    return Automata(new_states, new_state, new_transitions, set([target_state]),
                    nfa.start_anchor, nfa.end_anchor, nfa.deterministic)


def stringify_transitions(transitions):
    return ''.join([x.get_char() for x in transitions])

def find_hyper_vulnerabilities_for_pivot(state, nfa, dfa):
    for (transition, state_1, state_2) in get_potential_outgoing_tuples(state, nfa):
        nfa_1 = get_loopback_nfa(nfa, state, transition, state_1)
        nfa_2 = get_loopback_nfa(nfa, state, transition, state_2)
        intersection_nfa = nfa_1.intersection(nfa_2)
        if not intersection_nfa.has_accepting_states():
            continue

        repeat_pattern = intersection_nfa.find_shortest_path()
        initial_nfa = copy.deepcopy(nfa)
        initial_nfa.set_accepting_states([state])
        start_pattern = initial_nfa.find_shortest_path()

        prefix = stringify_transitions(start_pattern)
        repeat = stringify_transitions(repeat_pattern)

        terminating_string = find_terminating_string(state, nfa, dfa, prefix, repeat)
        if terminating_string is None:
            continue
        return prefix, repeat, terminating_string

    return None

def find_quadratic_vulnerabilities_for_pivot(state, nfa, dfa):
    for (transition, state_1, state_2) in get_potential_outgoing_tuples(state, nfa):
        nfa_1 = get_loopback_nfa(nfa, state, transition, state_1)
        nfa_p = copy.deepcopy(nfa)
        nfa_p.set_accepting_states([state])
        for q in nfa.get_states():
            new_state = nfa.get_new_state()
            transitions = nfa.copy_transitions()
            transitions.setdefault(new_state, {})[state_2] = transition
            nfa_2 = Automata(nfa.get_states().union(set([new_state])), new_state,
                             transitions, set([q]), False, False, False)
            nfa_3 = get_any_loopback_nfa(nfa, q)
            nfa_s = copy.deepcopy(nfa)
            nfa_s.set_initial_state(q)
            intersection_nfa = nfa_1.intersection(nfa_2)
            intersection_nfa = intersection_nfa.intersection(nfa_3)

            if not intersection_nfa.has_accepting_states():
                continue
            repeat_pattern = intersection_nfa.find_shortest_path()
            start_pattern = nfa_p.find_shortest_path()

            prefix = stringify_transitions(start_pattern)
            repeat = stringify_transitions(repeat_pattern)

            terminating_string = find_terminating_string(state, nfa, dfa, prefix, repeat)
            if terminating_string is None:
                continue
            return prefix, repeat, terminating_string

    return None


def find_terminating_string(state, nfa, dfa, prefix, repeat):
    new_nfa = copy.deepcopy(nfa)
    new_nfa.set_initial_state(state)
    if not new_nfa.match_string(repeat):
        return ''

    if not nfa.has_end_anchor():
        return None
    new_initial_state = dfa.traverse(prefix + repeat)
    if len(new_initial_state) == 0:
        raise RuntimeError('Failed to traverse DFA with prefix and repeat string')
    if len(new_initial_state) > 1:
        raise RuntimeError('More than one state returned when traversing DFA')

    tmp_dfa = copy.deepcopy(dfa)
    tmp_dfa.set_initial_state(next(iter(new_initial_state)))

    result = tmp_dfa.find_negation_accepting_string()
    return result


def find_hyper_vulnerabilities(nfa, dfa):
    for q in nfa.get_states():
        vuln = find_hyper_vulnerabilities_for_pivot(q, nfa, dfa)
        if vuln is None:
            continue
        return vuln

    return None

def find_quadratic_vulnerabilities(nfa, dfa):
    for q in nfa.get_states():
        vuln = find_quadratic_vulnerabilities_for_pivot(q, nfa, dfa)
        if vuln is None:
            continue
        return vuln

    return None

def exponential_match(x, a, b):
    return  b * (a ** x)

def quadratic_match(x, a, b):
    return b * (x ** a)

def verify_string(regex, prefix, repeat, suffix, exponential):
    lengths = []
    times = []
    collection_threshold = 2
    maximum_data_points = 100
    minimum_data_points = 10
    threshold = 1.3
    maximum_repeat = 2 ** 30
    i = 1
    prog = re.compile(regex)
    while len(times) < maximum_data_points:
        string = prefix + (i * repeat) + suffix
        # Use process_time to be better resilient to high system load
        start = time.process_time()
        prog.match(string)
        diff = time.process_time() - start
        times.append(diff)
        lengths.append(i)
        if diff > collection_threshold:
            break
        if exponential:
            i += 1
        else:
            i *= 2
        if i > maximum_repeat:
            raise RuntimeError('Failed to verify regex vulnerability as the length ' +
                               'became to long without reaching the time limit')

    if len(times) < minimum_data_points:
        raise RuntimeError('Failed to collect enough data points to verify')

    try:
        if exponential:
            (a, _), _ = curve_fit(exponential_match, lengths[-minimum_data_points:],
                                  times[-minimum_data_points:])
        else:
            (a, _), _ = curve_fit(quadratic_match, lengths[-minimum_data_points:],
                                  times[-minimum_data_points:])
    except RuntimeError:
        raise RuntimeError('Failed to match the curve to verify regular expression attack string') from None

    if a < threshold:
        raise RuntimeError('Failed to verify attack string ({}, {}, {}) for regex {}'.format(
            prefix, repeat, suffix, regex))


def run_regex(regex, show_nfa, max_length):
    nfa = regex_common.RegexParser().run(regex)
    dfa = regex_common.RegexParser(dfa=True).run(regex)

    if show_nfa:
        nfa.show_graph()

    exponential = True
    vulnerable_pattern = find_hyper_vulnerabilities(nfa, dfa)
    if vulnerable_pattern is None and options['include_quadratic']:
        vulnerable_pattern = find_quadratic_vulnerabilities(nfa, dfa)
        exponential = False
    if vulnerable_pattern is None:
        raise ValueError('Regex is not vulnerable to ReDoS attack')

    prefix, repeat, suffix = vulnerable_pattern
    if len(prefix) + len(repeat) + len(suffix) > max_length:
        raise ValueError('Max length too small, cannot exploit regex')

    if options['verify']:
        verify_string(regex, prefix, repeat, suffix, exponential)

    return prefix + (((max_length - len(prefix) - len(suffix)) // len(repeat)) * repeat) + suffix

def process_line(line):
    try:
        return (True, line, run_regex(line, False, options['max_length']))
    except ValueError as e:
        return (False, line, str(e))


def process_file(lines, progress_bar):
    results = []

    with mp.Pool(mp.cpu_count() if options['parallelize'] else 1) as pool:
        for i in pool.imap(process_line, lines):
            results.append(i)
            if progress_bar is not None:
                progress_bar.update(len(results))

    return results


def run(output):
    if options['use_file']:
        lines = set()
        with open(os.path.expanduser(options['regex_file']), encoding='ISO-8859-1') as f:
            for line in f:
                if (len(line) > 0) and (line[-1] == '\n'):
                    line = line[:-1]

                if len(line) == 0:
                    continue
                lines.add(line)

        if len(lines) == 0:
            raise ValueError('File is empty')

        if options['show_progress_bar']:
            with progressbar.ProgressBar(max_value=len(lines)) as progress_bar:
                results = process_file(lines, progress_bar)
        else:
            results = process_file(lines, None)

        if options['show_only_vulnerable']:
            results = [(x[1], x[2]) for x in results if x[0]]

            if len(results) == 0:
                raise ValueError('Failed to find any vulnerable regex')
        else:
            results = [(x[1], x[2]) for x in results]


        output.output(results)
    else:
        output.output([run_regex(options['regex'], options['show_nfa'], options['max_length'])])
