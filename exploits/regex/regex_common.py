from graphviz import Digraph
import ply.lex as lex
import ply.yacc as yacc
import copy
import tempfile
import string


class Transition:

    def __init__(self, epsilon=False, dot=False, character_class=None,
                 negation_character_class=None):
        if not epsilon and not dot and character_class is None and negation_character_class is None:
            raise ValueError('Must set one of the Transition constructor arguments')
        self.epsilon = epsilon
        self.dot = dot
        self.character_class = copy.copy(character_class)
        self.negation_character_class = copy.copy(negation_character_class)

    def is_epsilon(self):
        return self.epsilon

    def accepts_character(self, char):
        if self.dot:
            return True
        if self.character_class is not None:
            return char in self.character_class
        return char not in self.negation_character_class

    def get_char(self):
        if self.epsilon:
            return ''
        if self.dot:
            return 'a'
        if self.character_class is not None:
            return next(iter(self.character_class))
        # For negation first try all ASCII printable, then move to unicode
        for i in string.ascii_letters:
            if i not in self.negation_character_class:
                return i
        i = 0
        while True:
            if chr(i) not in self.negation_character_class:
                return chr(i)

    def intersection(self, other):
        if self.epsilon and other.epsilon:
            return Transition(epsilon=True)
        if self.epsilon or other.epsilon:
            return None

        # No longer need to worry about epsilon

        if self.dot and other.dot:
            return Transition(dot=True)

        if self.dot:
            return copy.deepcopy(other)
        if other.dot:
            return copy.deepcopy(self)

        # No longer need to worry about dot

        if self.character_class is None:
            if other.character_class is None:
                # bother negations are set
                return Transition(
                    negation_character_class=
                    self.negation_character_class | other.negation_character_class)
            else:
                intersecting_characters = other.character_class - self.negation_character_class
                # fallthrough
        else:
            if other.character_class is None:
                intersecting_characters = self.character_class - other.negation_character_class
                # fallthrough
            else:
                intersecting_characters = self.character_class & other.character_class
                # fallthrough

        if len(intersecting_characters) == 0:
            return None
        return Transition(character_class=intersecting_characters)

    def __str__(self):
        if self.epsilon:
            return '\u03B5'
        if self.dot:
            return '.'
        else:
            return ''.join(self.character_class)


class RegexParser:

    def __init__(self):
        lex.lex(module=self, debug=0)
        yacc.yacc(module=self, debug=0, write_tables=0)
        self.next_state = 0

    def new_state(self):
        result = self.next_state
        self.next_state += 1
        return result

    def run(self, s):
        self.next_state = 0
        return yacc.parse(s)

    @staticmethod
    def show_graph(nfa):
        g = Digraph("NFA Graph", filename=tempfile.mktemp(), format='png')
        g.attr('node', label="")

        for n in nfa['states']:
            if n in nfa['accepting_states'] and n not in nfa['initial_states']:
                g.node(str(n), str(n), shape='doublecircle')
            elif n not in nfa['accepting_states'] and n in nfa['initial_states']:
                g.node(str(n), str(n), shape='octagon')
            elif n in nfa['accepting_states'] and n in nfa['initial_states']:
                g.node(str(n), str(n), shape='doubleoctagon')
            else:
                g.node(str(n), str(n), shape='circle')

        for start_node, transitions in nfa['transitions'].items():
            for (dest, transition) in transitions.items():
                g.edge(str(start_node), str(dest), str(transition).replace('\\', '\\\\'))
        g.view(cleanup=True)

    @staticmethod
    def depth_first_search(nfa, state, last_real_state, position, input_string):

        for (dest, transition) in nfa['transitions'].get(state, {}).items():
            if not transition.is_epsilon():
                continue
            if (dest != last_real_state) and RegexParser.depth_first_search(
                    nfa, dest, last_real_state, position, input_string):
                return True

        if position == len(input_string):
            return state in nfa['accepting_states']

        char = input_string[position]

        for (dest, transition) in nfa['transitions'].get(state, {}).items():
            if transition.is_epsilon():
                continue
            if transition.accepts_character(char):
                if RegexParser.depth_first_search(nfa, dest, dest, position + 1, input_string):
                    return True
        return False

    @staticmethod
    def match_string(nfa, input_string):
        for i in nfa['initial_states']:
            if RegexParser.depth_first_search(nfa, i, i, 0, input_string):
                return True
        return False

    tokens = (
        'LITERAL',
        'ESCAPED_LITERAL',
        'DOT',
        'STAR',
        'PLUS',
        'OPTIONAL',
        'LEFT_PAREN',
        'RIGHT_PAREN',
        'ALTERNATE',
        'CHARACTER_CLASS_LIST',
        'DIGIT',
        'NON_DIGIT',
        'LEFT_CURLY_BRACKET',
        'RIGHT_CURLY_BRACKET',
        'NUMBER',
        'COMMA',
    )

    # Tokens

    t_LITERAL = r'.'
    t_ESCAPED_LITERAL = r'\\.'
    t_DOT = r'\.'
    t_CHARACTER_CLASS_LIST = r'\[[^\[\]]*\]'
    t_STAR = r'\*'
    t_PLUS = r'\+'
    t_OPTIONAL = r'\?'
    t_LEFT_PAREN = r'\('
    t_RIGHT_PAREN = r'\)'
    t_ALTERNATE = r'\|'
    t_DIGIT = r'\\d'
    t_NON_DIGIT = r'\\D'
    t_LEFT_CURLY_BRACKET = r'\{'
    t_RIGHT_CURLY_BRACKET = r'\}'
    t_NUMBER = r'\d+'
    t_COMMA = r','

    def t_error(self, t):
        raise ValueError("Illegal character '%s'" % t.value[0])

    # Parsing rules

    def p_exp(self, p):
        """
        exp : term ALTERNATE exp
            | term
        """
        if len(p) == 4:
            p[0] = self.alternate(p[1], p[3])
        else:
            p[0] = p[1]

    def p_term(self, p):
        """
        term : factor term
             | factor
        """
        if len(p) == 3:
            p[0] = self.concatenate(p[1], p[2])
        else:
            p[0] = p[1]

    def p_factor(self, p):
        """
        factor : primary STAR
               | primary PLUS
               | primary OPTIONAL
               | primary LEFT_CURLY_BRACKET NUMBER RIGHT_CURLY_BRACKET
               | primary LEFT_CURLY_BRACKET NUMBER COMMA RIGHT_CURLY_BRACKET
               | primary LEFT_CURLY_BRACKET NUMBER COMMA NUMBER RIGHT_CURLY_BRACKET
               | primary
        """
        if len(p) == 3:
            if p[2] == '*':
                p[0] = self.star(p[1])
            elif p[2] == '+':
                p[0] = self.plus(p[1])
            else:
                p[0] = self.optional_repeat(p[1], 1)
        elif len(p) == 5:
            p[0] = self.repeat(p[1], int(p[3]))
        elif len(p) == 6:
            start = self.repeat(p[1], int(p[3]))
            p[0] = self.concatenate(start, self.star(self.duplicate(p[1])))
        elif len(p) == 7:
            minimum = int(p[3])
            maximum = int(p[5])
            start = self.repeat(p[1], int(p[3]))
            p[0] = self.concatenate(start, self.optional_repeat(
                self.duplicate(p[1]), maximum - minimum))
        else:
            p[0] = p[1]

    def collect_characters_in_class(self, character_class):
        if len(character_class) == 0:
            raise ValueError("Empty character class")

        characters = set()
        if character_class[0] == '-':
            characters.add(character_class[0])
            i = 1
        else:
            i = 0
        while i < len(character_class):
            if (i + 2 < len(character_class)) and (character_class[i+1] == '-'):
                if ord(character_class[i]) > ord(character_class[i + 2]):
                    raise ValueError('{} is less than {} in character class'.format(
                        character_class[i], character_class[i+2]))
                for c in range(ord(character_class[i]), ord(character_class[i + 2]) + 1):
                    characters.add(chr(c))
                i += 2
            else:
                characters.add(character_class[i])
                i += 1
        return characters

    def character_class(self, character_class):
        chars = self.collect_characters_in_class(character_class)
        return self.single_element_nfa(chars)

    def negation_character_class(self, character_class):
        chars = self.collect_characters_in_class(character_class)
        return self.single_element_negation_nfa(chars)

    def p_character_class_list(self, p):
        """
        character_class_list : CHARACTER_CLASS_LIST
        """
        character_class = p[1][1:-1]

        if len(character_class) == 0:
            raise ValueError("Empty character class")

        if character_class[0] == '^':
            p[0] = self.negation_character_class(character_class[1:])
        else:
            p[0] = self.character_class(character_class)

    def dot(self):
        initial_state = self.new_state()
        accepting_state = self.new_state()
        transitions = {}
        transitions[initial_state] = { accepting_state: Transition(dot=True) }
        return {
            'states': set([initial_state, accepting_state]),
            'transitions': transitions,
            'initial_states': set([initial_state]),
            'accepting_states': set([accepting_state]),
        }

    def digit(self):
        return self.single_element_nfa(set(string.digits))

    def non_digit(self):
        return self.single_element_negation_nfa(set(string.digits))

    def whitespace(self):
        return self.single_element_nfa(set(string.whitespace))

    def non_whitespace(self):
        return self.single_element_negation_nfa(set(string.whitespace))

    def word_character(self):
        return self.single_element_nfa(set(string.ascii_letters + string.digits + '_'))

    def non_word_character(self):
        return self.single_element_negation_nfa(set(string.ascii_letters + string.digits + '_'))

    def merge_transitions(self, t1, t2):
        result = copy.deepcopy(t1)
        for s, transitions in t2.items():
            for (d, t) in transitions.items():
                self.add_transition(result, s, t, d)
        return result

    def duplicate(self, nfa):
        """Creates an indentical NFA with using new states"""
        state_mapping = {}
        new_states = set()
        for n in nfa['states']:
            state = self.new_state()
            state_mapping[n] = state
            new_states.add(state)

        new_transitions = {}
        for s, transitions in nfa['transitions'].items():
            for (d, t) in transitions.items():
                self.add_transition(new_transitions, state_mapping[s], t, state_mapping[d])

        return {
            'states': new_states,
            'transitions': new_transitions,
            'initial_states': { state_mapping[s] for s in nfa['initial_states'] },
            'accepting_states': { state_mapping[s] for s in nfa['accepting_states'] },
        }

    def optional_repeat(self, nfa, number):
        if number == 0:
            raise ValueError('Repeat number cannot be zero')
        new_states = [self.new_state() for _ in range(number + 1)]
        states = set(new_states)
        transitions = {}

        for i in range(number):
            self.add_transition(transitions, new_states[i], Transition(epsilon=True), new_states[number])

            duplicate_nfa = nfa if i == 0 else self.duplicate(nfa)
            states.update(duplicate_nfa['states'])
            transitions = self.merge_transitions(transitions, duplicate_nfa['transitions'])

            for s in duplicate_nfa['initial_states']:
                self.add_transition(transitions, new_states[i], Transition(epsilon=True), s)
            for s in duplicate_nfa['accepting_states']:
                self.add_transition(transitions, s, Transition(epsilon=True), new_states[i+1])

        return {
            'states': states,
            'transitions': transitions,
            'initial_states': set([new_states[0]]),
            'accepting_states': set([new_states[number]]),
        }

    def repeat(self, nfa, number):
        single_nfa = copy.deepcopy(nfa)
        if number == 0:
            raise ValueError('Repeat number cannot be zero')
        else:
            for i in range(number - 1):
                nfa = self.concatenate(nfa, self.duplicate(single_nfa))
        return nfa

    def p_primary(self, p):
        """
        primary : LEFT_PAREN exp RIGHT_PAREN
                | character_class_list
                | LITERAL
                | ESCAPED_LITERAL
                | DOT
                | DIGIT
                | NON_DIGIT
                | NUMBER
        """
        if len(p) == 4: # LEFT_PAREN exp RIGHT_PAREN
            p[0] = p[2]
        elif type(p[1]) == dict: # character_class_list
            p[0] = p[1]
        else: # LITERAL | ESCAPED_LITERAL | DOT
            if len(p[1]) == 2 and p[1][0] == '\\':
                if p[1] == '\d':
                    p[0] = self.digit()
                elif p[1] == '\D':
                    p[0] = self.non_digit()
                elif p[1] == '\s':
                    p[0] = self.whitespace()
                elif p[1] == '\S':
                    p[0] = self.non_whitespace()
                elif p[1] == '\w':
                    p[0] = self.word_character()
                elif p[1] == '\W':
                    p[0] = self.non_word_character()
                else:
                    p[0] = self.single_element_nfa({p[1][1]})
            elif p[1] == '.':
                p[0] = self.dot()
            else: # NUMBER that has no special meaning
                nfa = self.single_element_nfa({p[1][0]})
                for c in p[1][1:]:
                    nfa = self.concatenate(nfa, self.single_element_nfa({c}))
                p[0] = nfa

    def p_error(self, p):
        if p:
            raise ValueError("Syntax error at '%s'" % p.value)
        else:
            raise ValueError("Syntax error at EOF")

    def plus(self, nfa):
        new_state = self.new_state()
        transitions = copy.deepcopy(nfa['transitions'])
        for i in nfa['initial_states']:
            self.add_transition(transitions, new_state, Transition(epsilon=True), i)
        for a in nfa['accepting_states']:
            self.add_transition(transitions, a, Transition(epsilon=True), new_state)
        return {
            'states': nfa['states'].union([new_state]),
            'transitions': transitions,
            'initial_states': copy.deepcopy(nfa['initial_states']),
            'accepting_states': set([new_state]),
        }

    def star(self, nfa):
        new_state = self.new_state()
        transitions = copy.deepcopy(nfa['transitions'])
        for i in nfa['initial_states']:
            self.add_transition(transitions, new_state, Transition(epsilon=True), i)
        for a in nfa['accepting_states']:
            self.add_transition(transitions, a, Transition(epsilon=True), new_state)
        return {
            'states': nfa['states'].union([new_state]),
            'transitions': transitions,
            'initial_states': set([new_state]),
            'accepting_states': set([new_state]),
        }

    def alternate(self, left, right):
        if left is None or right is None:
            return copy.deepcopy(left if (right is None) else right)
        new_start_state = self.new_state()
        transitions = self.merge_transitions(left['transitions'], right['transitions'])
        for i in left['initial_states'].union(right['initial_states']):
            self.add_transition(transitions, new_start_state, Transition(epsilon=True), i)
        return {
            'states': left['states'].union(right['states'], [new_start_state]),
            'transitions': transitions,
            'initial_states': set([new_start_state]),
            'accepting_states': left['accepting_states'].union(right['accepting_states'])
        }

    def optional(self, nfa):
        new_start_state = self.new_state()
        new_final_state = self.new_state()
        transitions = copy.deepcopy(nfa['transitions'])
        for i in nfa['initial_states']:
            self.add_transition(transitions, new_start_state, Transition(epsilon=True), i)
        self.add_transition(transitions, new_start_state, Transition(epsilon=True), new_final_state)
        for a in nfa['accepting_states']:
            self.add_transition(transitions, a, Transition(epsilon=True), new_final_state)
        return {
            'states': nfa['states'].union([new_start_state, new_final_state]),
            'transitions': transitions,
            'initial_states': set([new_start_state]),
            'accepting_states': set([new_final_state]),
        }

    def add_transition(self, transitions, source, transition, destination):
        if destination in transitions.setdefault(source, {}):
            raise NotImplementedError('Transition union not implemented')
        else:
            transitions.setdefault(source, {})[destination] = transition

    def concatenate(self, left, right):
        transitions = self.merge_transitions(left['transitions'], right['transitions'])
        for a in left['accepting_states']:
            for i in right['initial_states']:
                self.add_transition(transitions, a, Transition(epsilon=True), i)
        return {
            'states': left['states'].union(right['states']),
            'transitions': transitions,
            'initial_states': copy.deepcopy(left['initial_states']),
            'accepting_states': copy.deepcopy(right['accepting_states']),
        }

    def single_element_nfa(self, transition_set):
        initial_state = self.new_state()
        accepting_state = self.new_state()
        transitions = {}
        transitions[initial_state] = {
            accepting_state: Transition(character_class=transition_set)
        }
        return {
            'states': set([initial_state, accepting_state]),
            'transitions': transitions,
            'initial_states': set([initial_state]),
            'accepting_states': set([accepting_state]),
        }

    def single_element_negation_nfa(self, transition_set):
        initial_state = self.new_state()
        accepting_state = self.new_state()
        transitions = {}
        transitions[initial_state] = {
            accepting_state: Transition(negation_character_class=transition_set)
        }
        return {
            'states': set([initial_state, accepting_state]),
            'transitions': transitions,
            'initial_states': set([initial_state]),
            'accepting_states': set([accepting_state]),
        }
