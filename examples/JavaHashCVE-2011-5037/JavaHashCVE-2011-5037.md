# Exploiting Java Hash Collisions with ACSploit 

## (creating a PoC for CVE 2011-5037)

One of our motivations behind creating ACSploit was to bridge the gap between discovery and exploitation as much as possible. For the purposes of STAC, what was most important was identifying a vulnerability. The hours that we spent constructing a working exploit were informative at first, but eventually we realized we were often re-inventing the wheel. In this example, we build a working exploit for a real-world CVE using ACSploit, based only on a high level description of the vulnerability.

In late 2011, Alexander Klink and Julian Wälde noted algorithmic complexity vulnerabilities in the hash functions of several popular web-based platforms. Essentially, several web-based technologies utilized hash functions for which pre-image attacks were practical (among these was the default Java hash function). While their findings led to several CVEs, for our demonstration we have chosen https://www.cvedetails.com/cve/CVE-2011-5037/ which targets the Java-based Apache Tomcat web server. Apache Tomcat stores variables from POST requests in a Java Hash table, and so a post request with a large number of variables that have colliding hashes will cause poor runtime behavior and will spike CPU utilization to 100% (effectively causing a DOS for a relatively small payload). 

For this example, we select Tomcat version 6.0.30, however there are several other vulnerable versions as noted in the CVE. We've included a Dockerfile in this directory that will pull and start a vulnerable Tomcat 6.0.30 server. To start (and background) the server simply run the following commands:

```
docker build .
docker run -dt -p 8080:8080 <image-name>
```

Klink and Wälde wrote PoC exploit code, but we will see how a user could easily generate their own malicious payloads using ACSploit and minimal scripting.  From the description of the CVE, we know that our payload will be a malicious http POST request. We also know that we want it to contain a list of variables that share a default Java hash value. Let's start by building a list of colliding Java hash pre-images using ACSploit.

We start ACsploit and examine the available exploits. 

<img src="../images/ACSploitOptions.png" class="center"  width="300">

After selecting hashes/collisions/java, we set our options. We know that we want to generate an output file with the hash collisions, so we set that option straight away. Examining the remaining options, we set some necessary parameters. We state that we want 100,000 collisions. Apache Tomcat accepts POST requests of at largest 2MB by default. Empirically, we found that 100,000 collisions sits comfortably between 1 and 2MB in size. This isn't very scientific, but it will suffice for a proof of concept. If we wanted to maximize the effect of our exploit we would optimize to fit in the 2MB size limit. We set the hash\_table\_size to 2^32, as this covers all integer values in Java. If we knew the hash table was reduced in size, we could scale appropriately for our collisions (e.g. if hashes were reduced modulo 1000). Finally we set the input generator to "char". This may seem unintuitive because the output will be a set of strings, but the exploit functions by manipulating and combining individual characters. Don't worry, ACSploit will give a helpful message if you supply an incorrect input or output generator. 


<img src="../images/ACSploitSetOptions.png" class="center" width="400">


We re-examine our options. Everything looks fine, so we are ready to run our exploit.


<img src="../images/JavaHashOptions.png" class="center"  width="300">


Okay, so we have our hash collisions. Next we format them so that they resemble http POST request variables (by replacing the newlines with "=&", we call the new file p100K.txt). For the remainder of the POST request, we'll embed that into our small python script shown below (there's nothing special about Python here, you can choose your favorite method of building and serving the POST request). 


<img src="../images/PythonPOSTrequestScript.png"  class="center" width="600">


A couple of things to note: the "host" ip address we used is not publicly accessible, you'll have to replace that address with the ip address of your own server. The "path" we supplied leads to a default example page on the Tomcat server that accepts user input to guess a random number. Notably, we need the page we target to accept POST requests, and this one just happens to fit the bill.  The outer for loop controls how many times we send the payload. To initiate a real DOS, an attacker may want to send hundreds or even thousands of payloads, but we only want to demonstrate a proof of concept. Ten payloads will be sufficient to run up the CPU on all the available threads on our target box.

Examining the target box with htop, we see that the CPU utilization of all 4 cores is at 100%.


<img src="../images/TomcatCPU.png" class="center" width="800" >
