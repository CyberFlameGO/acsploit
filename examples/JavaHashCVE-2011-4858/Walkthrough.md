# Exploiting Java Hash Collisions with ACsploit 

## Using ACsploit to create a PoC for CVE-2011-4858

A major design goal of ACsploit was to bridge as much of the gap between vulnerability discovery and exploitation as 
possible. In this example we build a working exploit for a real-world CVE using ACsploit, based only on a high level 
description of the vulnerability.

In late 2011 Alexander Klink and Julian WÃ¤lde noted algorithmic complexity vulnerabilities in the hash functions of 
several popular web-based platforms. In short, these platforms utilized hash functions vulnerable to practical pre-image
attacks. Among these functions was the default Java hash function. Thus, while their findings led to several CVEs, for
our demonstration we have chosen [CVE-2011-4858](https://www.cvedetails.com/cve/CVE-2011-4858/) which targets the 
Java-based [Apache Tomcat](http://tomcat.apache.org) web server. Apache Tomcat stores variables from `POST` requests in 
a Java Hash table and so a `POST` request with a large number of variables that have colliding hashes will cause poor 
runtime behavior and will spike CPU utilization to 100% (efficiently producing a DOS with a relatively small payload).

For this example, we select Tomcat version 6.0.30, but there are several other vulnerable versions as noted in the CVE. 
We've included a `Dockerfile` in this directory that will start a vulnerable Tomcat 6.0.30 server. To start the server 
and view its CPU usage in `htop` run the following commands:

```
docker build -t tomcat-cve-demo .
docker run -it -p 8080:8080 tomcat-cve-demo
```

From the description given in the CVE we know that our payload will be a malicious `HTTP POST` request. We also know 
that we want it to contain a list of variables that share the same Java hash value. Let's begin by building a list of 
colliding Java hash pre-images using ACsploit.

We start ACsploit and examine the available exploits.

<img src="images/ACsploitOptions.png" class="center"  width="300">

After selecting `hashes/collisions/java_fast` as our exploit, we set our `options`.

Apache Tomcat accepts `POST` requests of at most 2MB by default, so generating more collisions than will fit in 2MB 
would be a waste. Empirically, we found that 50,000 collisions sits comfortably between 1 and 2MB in size, so we set 
`n_collisions` to `50000`. This isn't optimal, but more than suffices for a proof of concept. If we wanted to maximize
the effect of our exploit we could spend a bit longer optimizing the number of collisions that would fit in 2MB.

Note that we leave the `input` generator set to `char`. This may seem unintuitive because the output will be a set of 
strings, but the exploit generates its collisions by manipulating and combining individual characters, and so must be 
given individual characters to work with. The default behavior for the `char` input is to generate strings with all
lowercase letters.

Using ACsploit's `http` output allows us to send our collisions directly to a web server. We set `output.url` to our 
target: `http://127.0.0.1:8080/examples/jsp/num/numguess.jsp`, which leads to a default example page on the Tomcat 
server that accepts user input to guess a random number. Any page will do as a target as long as it accepts `POST` 
requests. Next, we set `output.http_method` to `POST`. We want to submit our collisions as parameters in the body of
the request, so we set `output.use_body` to `True` and run `set output.separator custom =&` to chain together
the collisions. Finally, we set `output.content_type` to `application/x-www-form-urlencoded`.

<img src="images/JavaHashOptions.png" class="center"  width="800">

We re-examine our options. Everything looks fine, so we are ready to run our exploit with `run`. Generating 100,000 
collisions takes about 60 seconds. Once the collisions have been generated, the http output module sends the malicious
payload to the vulnerable Tomcat page. This causes one CPU in the Docker container to spike to near 100% for 1-2 minutes.

<img src="images/TomcatCPU.png" class="center"  width="800">

Repeating this exercise with the `php5_fast` exploit will not produce the same effect, demonstrating that the Java 
collisions cause the CPU spike, not simply the size of the generated payload.
